package grammar

// Code generated by peg query.peg DO NOT EDIT.


import (
	"fmt"
	"io"
	"os"
	"sort"
	"strconv"
	"strings"
	
)

const endSymbol rune = 1114112

/* The rule types inferred from the grammar are below. */
type pegRule uint8

const (
	ruleUnknown pegRule = iota
	ruleQuery
	ruleTypeSpec
	ruleFilter
	ruleConditions
	ruleTerm
	ruleConjunctive
	ruleFunction
	ruleUnaryFunction
	ruleUnaryFunctionName
	ruleBinaryFunctionName
	ruleOperator
	ruleBinaryFunction
	ruleInfixExpression
	ruleLiteralConditionValue
	ruleMetrics
	ruleIdentifier
	ruleIdentifierList
	ruleLiteralStringList
	ruleIDStartCharacter
	ruleIDCharacter
	ruleIDQuotedCharacter
	ruleLiteralString
	ruleMETRICS
	ruleNAME
	ruleREGEX
	ruleRESOURCE
	ruleWHERE_HEALTH
	ruleWHERE_STATE
	ruleWHERE_STATUS
	ruleAND
	ruleOR
	ruleIN
	ruleNOT_IN
	ruleCONTAINS
	ruleSTARTS_WITH
	ruleENDS_WITH
	ruleNOT_STARTS_WITH
	ruleNOT_ENDS_WITH
	ruleNOT_CONTAINS
	ruleNOT_REGEX
	ruleEXISTS
	ruleNOT_EXISTS
	ruleGT
	ruleLT
	ruleGTE
	ruleLTE
	ruleEQ
	ruleNE
	ruleQuote
	ruleComma
	ruleBackTick
	ruleDot
	ruleLP
	ruleRP
	rule_
	ruleLiteralChar
	ruleFloat
	ruleDigit
	ruleAction0
	ruleAction1
	ruleAction2
	ruleAction3
	ruleAction4
	ruleAction5
	ruleAction6
	ruleAction7
	ruleAction8
	ruleAction9
	ruleAction10
	ruleAction11
	ruleWHERE_METRICS
	ruleAction12
	ruleAction13
	ruleAction14
	rulePegText
	ruleAction15
	ruleAction16
	ruleAction17
	ruleAction18
	ruleAction19
	ruleAction20
	ruleAction21
	ruleAction22
	ruleAction23
	ruleAction24
	ruleAction25
	ruleAction26
	ruleAction27
	ruleAction28
	ruleAction29
	ruleAction30
	
)

var rul3s = [...]string {
	"Unknown",
	"Query",
	"TypeSpec",
	"Filter",
	"Conditions",
	"Term",
	"Conjunctive",
	"Function",
	"UnaryFunction",
	"UnaryFunctionName",
	"BinaryFunctionName",
	"Operator",
	"BinaryFunction",
	"InfixExpression",
	"LiteralConditionValue",
	"Metrics",
	"Identifier",
	"IdentifierList",
	"LiteralStringList",
	"IDStartCharacter",
	"IDCharacter",
	"IDQuotedCharacter",
	"LiteralString",
	"METRICS",
	"NAME",
	"REGEX",
	"RESOURCE",
	"WHERE_HEALTH",
	"WHERE_STATE",
	"WHERE_STATUS",
	"AND",
	"OR",
	"IN",
	"NOT_IN",
	"CONTAINS",
	"STARTS_WITH",
	"ENDS_WITH",
	"NOT_STARTS_WITH",
	"NOT_ENDS_WITH",
	"NOT_CONTAINS",
	"NOT_REGEX",
	"EXISTS",
	"NOT_EXISTS",
	"GT",
	"LT",
	"GTE",
	"LTE",
	"EQ",
	"NE",
	"Quote",
	"Comma",
	"BackTick",
	"Dot",
	"LP",
	"RP",
	"_",
	"LiteralChar",
	"Float",
	"Digit",
	"Action0",
	"Action1",
	"Action2",
	"Action3",
	"Action4",
	"Action5",
	"Action6",
	"Action7",
	"Action8",
	"Action9",
	"Action10",
	"Action11",
	"WHERE_METRICS",
	"Action12",
	"Action13",
	"Action14",
	"PegText",
	"Action15",
	"Action16",
	"Action17",
	"Action18",
	"Action19",
	"Action20",
	"Action21",
	"Action22",
	"Action23",
	"Action24",
	"Action25",
	"Action26",
	"Action27",
	"Action28",
	"Action29",
	"Action30",
	
}

type token32 struct {
	pegRule
	begin, end uint32
}

func (t *token32) String() string {
	return fmt.Sprintf("\x1B[34m%v\x1B[m %v %v", rul3s[t.pegRule], t.begin, t.end)
}


type node32 struct {
	token32
	up, next *node32
}

func (node *node32) print(w io.Writer, pretty bool, buffer string) {
	var print func(node *node32, depth int)
	print = func(node *node32, depth int) {
		for node != nil {
			for c := 0; c < depth; c++ {
				fmt.Fprintf(w, " ")
			}
			rule := rul3s[node.pegRule]
			quote := strconv.Quote(string(([]rune(buffer)[node.begin:node.end])))
			if !pretty {
				fmt.Fprintf(w, "%v %v\n", rule, quote)
			} else {
				fmt.Fprintf(w, "\x1B[36m%v\x1B[m %v\n", rule, quote)
			}
			if node.up != nil {
				print(node.up, depth + 1)
			}
			node = node.next
		}
	}
	print(node, 0)
}

func (node *node32) Print(w io.Writer, buffer string) {
	node.print(w, false, buffer)
}

func (node *node32) PrettyPrint(w io.Writer, buffer string) {
	node.print(w, true, buffer)
}

type tokens32 struct {
	tree		[]token32
}

func (t *tokens32) Trim(length uint32) {
	t.tree = t.tree[:length]
}

func (t *tokens32) Print() {
	for _, token := range t.tree {
		fmt.Println(token.String())
	}
}

func (t *tokens32) AST() *node32 {
	type element struct {
		node *node32
		down *element
	}
	tokens := t.Tokens()
	var stack *element
	for _, token := range tokens {
		if token.begin == token.end {
			continue
		}
		node := &node32{token32: token}
		for stack != nil && stack.node.begin >= token.begin && stack.node.end <= token.end {
			stack.node.next = node.up
			node.up = stack.node
			stack = stack.down
		}
		stack = &element{node: node, down: stack}
	}
	if stack != nil {
		return stack.node
	}
	return nil
}

func (t *tokens32) PrintSyntaxTree(buffer string) {
	t.AST().Print(os.Stdout, buffer)
}

func (t *tokens32) WriteSyntaxTree(w io.Writer, buffer string) {
	t.AST().Print(w, buffer)
}

func (t *tokens32) PrettyPrintSyntaxTree(buffer string) {
	t.AST().PrettyPrint(os.Stdout, buffer)
}

func (t *tokens32) Add(rule pegRule, begin, end, index uint32) {
	tree, i := t.tree, int(index)
	if i >= len(tree) {
		t.tree = append(tree, token32{pegRule: rule, begin: begin, end: end})
		return
	}
	tree[i] = token32{pegRule: rule, begin: begin, end: end}
}

func (t *tokens32) Tokens() []token32 {
	return t.tree
}


type QueryParser struct {
	
    Query RawQuery;

    currentText string
    currentList []string
    currentCondition Condition
    currentConditions []Condition
    currentConjunctive int    

	Buffer		string
	buffer		[]rune
	rules		[93]func() bool
	parse		func(rule ...int) error
	reset		func()
	Pretty 	bool
tokens32
}

func (p *QueryParser) Parse(rule ...int) error {
	return p.parse(rule...)
}

func (p *QueryParser) Reset() {
	p.reset()
}

type textPosition struct {
	line, symbol int
}

type textPositionMap map[int] textPosition

func translatePositions(buffer []rune, positions []int) textPositionMap {
	length, translations, j, line, symbol := len(positions), make(textPositionMap, len(positions)), 0, 1, 0
	sort.Ints(positions)

	search: for i, c := range buffer {
		if c == '\n' {line, symbol = line + 1, 0} else {symbol++}
		if i == positions[j] {
			translations[positions[j]] = textPosition{line, symbol}
			for j++; j < length; j++ {if i != positions[j] {continue search}}
			break search
		}
 	}

	return translations
}

type parseError struct {
	p *QueryParser
	max token32
}

func (e *parseError) Error() string {
	tokens, err := []token32{e.max}, "\n"
	positions, p := make([]int, 2 * len(tokens)), 0
	for _, token := range tokens {
		positions[p], p = int(token.begin), p + 1
		positions[p], p = int(token.end), p + 1
	}
	translations := translatePositions(e.p.buffer, positions)
	format := "parse error near %v (line %v symbol %v - line %v symbol %v):\n%v\n"
	if e.p.Pretty {
		format = "parse error near \x1B[34m%v\x1B[m (line %v symbol %v - line %v symbol %v):\n%v\n"
	}
	for _, token := range tokens {
		begin, end := int(token.begin), int(token.end)
		err += fmt.Sprintf(format,
                         rul3s[token.pegRule],
                         translations[begin].line, translations[begin].symbol,
                         translations[end].line, translations[end].symbol,
                         strconv.Quote(string(e.p.buffer[begin:end])))
	}

	return err
}


func (p *QueryParser) PrintSyntaxTree() {
	if p.Pretty {
		p.tokens32.PrettyPrintSyntaxTree(p.Buffer)
	} else {
		p.tokens32.PrintSyntaxTree(p.Buffer)
	}
}

func (p *QueryParser) WriteSyntaxTree(w io.Writer) {
	p.tokens32.WriteSyntaxTree(w, p.Buffer)
}

func (p *QueryParser) SprintSyntaxTree() string {
	var bldr strings.Builder
	p.WriteSyntaxTree(&bldr)
	return bldr.String()
}


func (p *QueryParser) Execute() {
	buffer, _buffer, text, begin, end := p.Buffer, p.buffer, "", 0, 0
	for _, token := range p.Tokens() {
		switch (token.pegRule) {
		
		case rulePegText:
			begin, end = int(token.begin), int(token.end)
			text = string(_buffer[begin:end])
		
		case ruleAction0:
			 p.currentList = make([]string, 0) 
		case ruleAction1:
			 p.Query.ResourceKinds = p.currentList 
		case ruleAction2:
			 p.currentList = make([]string, 0) 
		case ruleAction3:
			 p.Query.Name = p.currentList 
		case ruleAction4:
			 p.currentList = make([]string, 0) 
		case ruleAction5:
			 p.Query.Regex = p.currentList 
		case ruleAction6:
			 p.currentList = make([]string, 0) 
		case ruleAction7:
			 p.Query.Health = p.currentList 
		case ruleAction8:
			 p.currentList = make([]string, 0) 
		case ruleAction9:
			 p.Query.Status = p.currentList 
		case ruleAction10:
			 p.currentList = make([]string, 0) 
		case ruleAction11:
			 p.Query.State = p.currentList 
		case ruleAction12:
			 p.currentConditions = make([]Condition, 0) 
		case ruleAction13:
			 p.Query.MetricsConditions = p.currentConditions 
		case ruleAction14:
			 p.currentConditions = append(p.currentConditions, p.currentCondition.withConjunction(AndConjuction)) 
		case ruleAction15:
			 p.currentConjunction = text == "OR" ? OrConjuctive : AndConjuctive 
		case ruleAction16:
			 p.currentConditions = append(p.currentConditions, p.currentCondition) 
		case ruleAction17:
			 p.currentCondition.Operator = text
		case ruleAction18:
			 p.currentCondition.Identifier = text 
		case ruleAction19:
			 p.currentCondition.Operator = text
		case ruleAction20:
			 p.currentCondition.Identifier = text
		case ruleAction21:
			 p.currentCondition.Operator = text 
		case ruleAction22:
			 p.currentCondition.StringValue = text 
		case ruleAction23:
			 p.currentCondition.DoubleValue = strconv.ParseFloat(text, 64) 
		case ruleAction24:
			 p.currentList = make([]string, 0) 
		case ruleAction25:
			 p.Query.Metrics = p.currentList
		case ruleAction26:
			 p.currentList = append(p.currentList, text)
		case ruleAction27:
			 p.currentList = append(p.currentList, text)
		case ruleAction28:
			 p.currentList = append(p.currentList, p.currentText )
		case ruleAction29:
			 p.currentList = append(p.currentList, p.currentText) 
		case ruleAction30:
			 p.currentText = text 
		
		}
	}
	_, _, _, _, _ = buffer, _buffer, text, begin, end
}



func Pretty(pretty bool) func(*QueryParser) error {
	return func(p *QueryParser) error {
		p.Pretty = pretty
		return nil
	}
}

func Size(size int) func(*QueryParser) error {
	return func(p *QueryParser) error {
		p.tokens32 = tokens32{tree: make([]token32, 0, size)}
		return nil
	}
}
func (p *QueryParser) Init(options ...func(*QueryParser) error) error {
	var (
		max token32
		position, tokenIndex uint32
		buffer []rune
)
	for _, option := range options {
		err := option(p)
		if err != nil {
			return err
		}
	}
	p.reset = func() {
		max = token32{}
		position, tokenIndex = 0, 0

		p.buffer = []rune(p.Buffer)
		if len(p.buffer) == 0 || p.buffer[len(p.buffer) - 1] != endSymbol {
			p.buffer = append(p.buffer, endSymbol)
		}
		buffer = p.buffer
	}
	p.reset()

	_rules := p.rules
tree := p.tokens32
p.parse = func(rule ...int) error {
		r := 1
		if len(rule) > 0 {
			r = rule[0]
		}
		matches := p.rules[r]()
p.tokens32 = tree
if matches {
p.Trim(tokenIndex)
return nil
		}
		return &parseError{p, max}
	}

	add := func(rule pegRule, begin uint32) {
tree.Add(rule, begin, position, tokenIndex)
tokenIndex++
		if begin != position && position > max.end {
			max = token32{rule, begin, position}
		}
	}

	
	matchDot := func() bool {
		if buffer[position] != endSymbol {
			position++
			return true
		}
		return false
	}
	

	
	/*matchChar := func(c byte) bool {
		if buffer[position] == c {
			position++
			return true
		}
		return false
	}*/
	

	

	
	/*matchRange := func(lower byte, upper byte) bool {
		if c := buffer[position]; c >= lower && c <= upper {
			position++
			return true
		}
		return false
	}*/
	

	_rules = [...]func() bool {
		nil,
  /* 0 Query <- <(TypeSpec (Dot Filter)+ Dot Metrics !.)> */
  func() bool {
   position0, tokenIndex0 := position, tokenIndex
   {
position1 := position
   if !_rules[ruleTypeSpec]() {
   goto l0}
   if !_rules[ruleDot]() {
   goto l0}
   if !_rules[ruleFilter]() {
   goto l0}
   l2:	
   {
   position3, tokenIndex3 := position, tokenIndex
   if !_rules[ruleDot]() {
   goto l3}
   if !_rules[ruleFilter]() {
   goto l3}
   goto l2
   l3:	
   position, tokenIndex = position3, tokenIndex3
   }
   if !_rules[ruleDot]() {
   goto l0}
   if !_rules[ruleMetrics]() {
   goto l0}
   {
   position4, tokenIndex4 := position, tokenIndex
   if !matchDot() {
   goto l4}
   goto l0
   l4:	
   position, tokenIndex = position4, tokenIndex4
   }
add(ruleQuery, position1)
   }
   return true
   l0:	
   position, tokenIndex = position0, tokenIndex0
   return false
  },
  /* 1 TypeSpec <- <(RESOURCE Action0 LP IdentifierList RP Action1)> */
  func() bool {
   position5, tokenIndex5 := position, tokenIndex
   {
position6 := position
   if !_rules[ruleRESOURCE]() {
   goto l5}
   if !_rules[ruleAction0]() {
   goto l5}
   if !_rules[ruleLP]() {
   goto l5}
   if !_rules[ruleIdentifierList]() {
   goto l5}
   if !_rules[ruleRP]() {
   goto l5}
   if !_rules[ruleAction1]() {
   goto l5}
add(ruleTypeSpec, position6)
   }
   return true
   l5:	
   position, tokenIndex = position5, tokenIndex5
   return false
  },
  /* 2 Filter <- <((NAME Action2 LP LiteralStringList RP Action3) / (REGEX Action4 LP LiteralStringList RP Action5) / (WHERE_HEALTH Action6 LP IdentifierList RP Action7) / (WHERE_STATUS Action8 LP IdentifierList RP Action9) / (WHERE_STATE Action10 LP IdentifierList RP Action11) / (WHERE_METRICS Action12 LP Conditions RP Action13))> */
  func() bool {
   position7, tokenIndex7 := position, tokenIndex
   {
position8 := position
   {
   position9, tokenIndex9 := position, tokenIndex
   if !_rules[ruleNAME]() {
   goto l10}
   if !_rules[ruleAction2]() {
   goto l10}
   if !_rules[ruleLP]() {
   goto l10}
   if !_rules[ruleLiteralStringList]() {
   goto l10}
   if !_rules[ruleRP]() {
   goto l10}
   if !_rules[ruleAction3]() {
   goto l10}
   goto l9
   l10:	
   position, tokenIndex = position9, tokenIndex9
   if !_rules[ruleREGEX]() {
   goto l11}
   if !_rules[ruleAction4]() {
   goto l11}
   if !_rules[ruleLP]() {
   goto l11}
   if !_rules[ruleLiteralStringList]() {
   goto l11}
   if !_rules[ruleRP]() {
   goto l11}
   if !_rules[ruleAction5]() {
   goto l11}
   goto l9
   l11:	
   position, tokenIndex = position9, tokenIndex9
   if !_rules[ruleWHERE_HEALTH]() {
   goto l12}
   if !_rules[ruleAction6]() {
   goto l12}
   if !_rules[ruleLP]() {
   goto l12}
   if !_rules[ruleIdentifierList]() {
   goto l12}
   if !_rules[ruleRP]() {
   goto l12}
   if !_rules[ruleAction7]() {
   goto l12}
   goto l9
   l12:	
   position, tokenIndex = position9, tokenIndex9
   if !_rules[ruleWHERE_STATUS]() {
   goto l13}
   if !_rules[ruleAction8]() {
   goto l13}
   if !_rules[ruleLP]() {
   goto l13}
   if !_rules[ruleIdentifierList]() {
   goto l13}
   if !_rules[ruleRP]() {
   goto l13}
   if !_rules[ruleAction9]() {
   goto l13}
   goto l9
   l13:	
   position, tokenIndex = position9, tokenIndex9
   if !_rules[ruleWHERE_STATE]() {
   goto l14}
   if !_rules[ruleAction10]() {
   goto l14}
   if !_rules[ruleLP]() {
   goto l14}
   if !_rules[ruleIdentifierList]() {
   goto l14}
   if !_rules[ruleRP]() {
   goto l14}
   if !_rules[ruleAction11]() {
   goto l14}
   goto l9
   l14:	
   position, tokenIndex = position9, tokenIndex9
   if !_rules[ruleWHERE_METRICS]() {
   goto l7}
   if !_rules[ruleAction12]() {
   goto l7}
   if !_rules[ruleLP]() {
   goto l7}
   if !_rules[ruleConditions]() {
   goto l7}
   if !_rules[ruleRP]() {
   goto l7}
   if !_rules[ruleAction13]() {
   goto l7}
   }
   l9:	
add(ruleFilter, position8)
   }
   return true
   l7:	
   position, tokenIndex = position7, tokenIndex7
   return false
  },
  /* 3 Conditions <- <(Term Action14 (<Conjunctive> Action15 Term Action16)*)> */
  func() bool {
   position15, tokenIndex15 := position, tokenIndex
   {
position16 := position
   if !_rules[ruleTerm]() {
   goto l15}
   if !_rules[ruleAction14]() {
   goto l15}
   l17:	
   {
   position18, tokenIndex18 := position, tokenIndex
   {
position19 := position
   if !_rules[ruleConjunctive]() {
   goto l18}
add(rulePegText, position19)
   }
   if !_rules[ruleAction15]() {
   goto l18}
   if !_rules[ruleTerm]() {
   goto l18}
   if !_rules[ruleAction16]() {
   goto l18}
   goto l17
   l18:	
   position, tokenIndex = position18, tokenIndex18
   }
add(ruleConditions, position16)
   }
   return true
   l15:	
   position, tokenIndex = position15, tokenIndex15
   return false
  },
  /* 4 Term <- <(Function / InfixExpression)> */
  func() bool {
   position20, tokenIndex20 := position, tokenIndex
   {
position21 := position
   {
   position22, tokenIndex22 := position, tokenIndex
   if !_rules[ruleFunction]() {
   goto l23}
   goto l22
   l23:	
   position, tokenIndex = position22, tokenIndex22
   if !_rules[ruleInfixExpression]() {
   goto l20}
   }
   l22:	
add(ruleTerm, position21)
   }
   return true
   l20:	
   position, tokenIndex = position20, tokenIndex20
   return false
  },
  /* 5 Conjunctive <- <(AND / OR)> */
  func() bool {
   position24, tokenIndex24 := position, tokenIndex
   {
position25 := position
   {
   position26, tokenIndex26 := position, tokenIndex
   if !_rules[ruleAND]() {
   goto l27}
   goto l26
   l27:	
   position, tokenIndex = position26, tokenIndex26
   if !_rules[ruleOR]() {
   goto l24}
   }
   l26:	
add(ruleConjunctive, position25)
   }
   return true
   l24:	
   position, tokenIndex = position24, tokenIndex24
   return false
  },
  /* 6 Function <- <(UnaryFunction / BinaryFunction)> */
  func() bool {
   position28, tokenIndex28 := position, tokenIndex
   {
position29 := position
   {
   position30, tokenIndex30 := position, tokenIndex
   if !_rules[ruleUnaryFunction]() {
   goto l31}
   goto l30
   l31:	
   position, tokenIndex = position30, tokenIndex30
   if !_rules[ruleBinaryFunction]() {
   goto l28}
   }
   l30:	
add(ruleFunction, position29)
   }
   return true
   l28:	
   position, tokenIndex = position28, tokenIndex28
   return false
  },
  /* 7 UnaryFunction <- <(<UnaryFunctionName> Action17 LP <Identifier> Action18 RP)> */
  func() bool {
   position32, tokenIndex32 := position, tokenIndex
   {
position33 := position
   {
position34 := position
   if !_rules[ruleUnaryFunctionName]() {
   goto l32}
add(rulePegText, position34)
   }
   if !_rules[ruleAction17]() {
   goto l32}
   if !_rules[ruleLP]() {
   goto l32}
   {
position35 := position
   if !_rules[ruleIdentifier]() {
   goto l32}
add(rulePegText, position35)
   }
   if !_rules[ruleAction18]() {
   goto l32}
   if !_rules[ruleRP]() {
   goto l32}
add(ruleUnaryFunction, position33)
   }
   return true
   l32:	
   position, tokenIndex = position32, tokenIndex32
   return false
  },
  /* 8 UnaryFunctionName <- <(EXISTS / NOT_EXISTS)> */
  func() bool {
   position36, tokenIndex36 := position, tokenIndex
   {
position37 := position
   {
   position38, tokenIndex38 := position, tokenIndex
   if !_rules[ruleEXISTS]() {
   goto l39}
   goto l38
   l39:	
   position, tokenIndex = position38, tokenIndex38
   if !_rules[ruleNOT_EXISTS]() {
   goto l36}
   }
   l38:	
add(ruleUnaryFunctionName, position37)
   }
   return true
   l36:	
   position, tokenIndex = position36, tokenIndex36
   return false
  },
  /* 9 BinaryFunctionName <- <(CONTAINS / STARTS_WITH / ENDS_WITH / REGEX / NOT_CONTAINS / NOT_STARTS_WITH / NOT_ENDS_WITH / NOT_REGEX / IN / NOT_IN)> */
  func() bool {
   position40, tokenIndex40 := position, tokenIndex
   {
position41 := position
   {
   position42, tokenIndex42 := position, tokenIndex
   if !_rules[ruleCONTAINS]() {
   goto l43}
   goto l42
   l43:	
   position, tokenIndex = position42, tokenIndex42
   if !_rules[ruleSTARTS_WITH]() {
   goto l44}
   goto l42
   l44:	
   position, tokenIndex = position42, tokenIndex42
   if !_rules[ruleENDS_WITH]() {
   goto l45}
   goto l42
   l45:	
   position, tokenIndex = position42, tokenIndex42
   if !_rules[ruleREGEX]() {
   goto l46}
   goto l42
   l46:	
   position, tokenIndex = position42, tokenIndex42
   if !_rules[ruleNOT_CONTAINS]() {
   goto l47}
   goto l42
   l47:	
   position, tokenIndex = position42, tokenIndex42
   if !_rules[ruleNOT_STARTS_WITH]() {
   goto l48}
   goto l42
   l48:	
   position, tokenIndex = position42, tokenIndex42
   if !_rules[ruleNOT_ENDS_WITH]() {
   goto l49}
   goto l42
   l49:	
   position, tokenIndex = position42, tokenIndex42
   if !_rules[ruleNOT_REGEX]() {
   goto l50}
   goto l42
   l50:	
   position, tokenIndex = position42, tokenIndex42
   if !_rules[ruleIN]() {
   goto l51}
   goto l42
   l51:	
   position, tokenIndex = position42, tokenIndex42
   if !_rules[ruleNOT_IN]() {
   goto l40}
   }
   l42:	
add(ruleBinaryFunctionName, position41)
   }
   return true
   l40:	
   position, tokenIndex = position40, tokenIndex40
   return false
  },
  /* 10 Operator <- <(EQ / NE / LT / LTE / GT / GTE)> */
  func() bool {
   position52, tokenIndex52 := position, tokenIndex
   {
position53 := position
   {
   position54, tokenIndex54 := position, tokenIndex
   if !_rules[ruleEQ]() {
   goto l55}
   goto l54
   l55:	
   position, tokenIndex = position54, tokenIndex54
   if !_rules[ruleNE]() {
   goto l56}
   goto l54
   l56:	
   position, tokenIndex = position54, tokenIndex54
   if !_rules[ruleLT]() {
   goto l57}
   goto l54
   l57:	
   position, tokenIndex = position54, tokenIndex54
   if !_rules[ruleLTE]() {
   goto l58}
   goto l54
   l58:	
   position, tokenIndex = position54, tokenIndex54
   if !_rules[ruleGT]() {
   goto l59}
   goto l54
   l59:	
   position, tokenIndex = position54, tokenIndex54
   if !_rules[ruleGTE]() {
   goto l52}
   }
   l54:	
add(ruleOperator, position53)
   }
   return true
   l52:	
   position, tokenIndex = position52, tokenIndex52
   return false
  },
  /* 11 BinaryFunction <- <(<BinaryFunctionName> Action19 LP <Identifier> Action20 Comma LiteralConditionValue RP)> */
  func() bool {
   position60, tokenIndex60 := position, tokenIndex
   {
position61 := position
   {
position62 := position
   if !_rules[ruleBinaryFunctionName]() {
   goto l60}
add(rulePegText, position62)
   }
   if !_rules[ruleAction19]() {
   goto l60}
   if !_rules[ruleLP]() {
   goto l60}
   {
position63 := position
   if !_rules[ruleIdentifier]() {
   goto l60}
add(rulePegText, position63)
   }
   if !_rules[ruleAction20]() {
   goto l60}
   if !_rules[ruleComma]() {
   goto l60}
   if !_rules[ruleLiteralConditionValue]() {
   goto l60}
   if !_rules[ruleRP]() {
   goto l60}
add(ruleBinaryFunction, position61)
   }
   return true
   l60:	
   position, tokenIndex = position60, tokenIndex60
   return false
  },
  /* 12 InfixExpression <- <(Identifier _ <Operator> Action21 _ LiteralConditionValue)> */
  func() bool {
   position64, tokenIndex64 := position, tokenIndex
   {
position65 := position
   if !_rules[ruleIdentifier]() {
   goto l64}
   if !_rules[rule_]() {
   goto l64}
   {
position66 := position
   if !_rules[ruleOperator]() {
   goto l64}
add(rulePegText, position66)
   }
   if !_rules[ruleAction21]() {
   goto l64}
   if !_rules[rule_]() {
   goto l64}
   if !_rules[ruleLiteralConditionValue]() {
   goto l64}
add(ruleInfixExpression, position65)
   }
   return true
   l64:	
   position, tokenIndex = position64, tokenIndex64
   return false
  },
  /* 13 LiteralConditionValue <- <((<LiteralString> Action22) / (<Float> Action23))> */
  func() bool {
   position67, tokenIndex67 := position, tokenIndex
   {
position68 := position
   {
   position69, tokenIndex69 := position, tokenIndex
   {
position71 := position
   if !_rules[ruleLiteralString]() {
   goto l70}
add(rulePegText, position71)
   }
   if !_rules[ruleAction22]() {
   goto l70}
   goto l69
   l70:	
   position, tokenIndex = position69, tokenIndex69
   {
position72 := position
   if !_rules[ruleFloat]() {
   goto l67}
add(rulePegText, position72)
   }
   if !_rules[ruleAction23]() {
   goto l67}
   }
   l69:	
add(ruleLiteralConditionValue, position68)
   }
   return true
   l67:	
   position, tokenIndex = position67, tokenIndex67
   return false
  },
  /* 14 Metrics <- <(METRICS Action24 LP IdentifierList RP Action25)> */
  func() bool {
   position73, tokenIndex73 := position, tokenIndex
   {
position74 := position
   if !_rules[ruleMETRICS]() {
   goto l73}
   if !_rules[ruleAction24]() {
   goto l73}
   if !_rules[ruleLP]() {
   goto l73}
   if !_rules[ruleIdentifierList]() {
   goto l73}
   if !_rules[ruleRP]() {
   goto l73}
   if !_rules[ruleAction25]() {
   goto l73}
add(ruleMetrics, position74)
   }
   return true
   l73:	
   position, tokenIndex = position73, tokenIndex73
   return false
  },
  /* 15 Identifier <- <((IDStartCharacter IDCharacter*) / (BackTick <IDQuotedCharacter+> BackTick))> */
  func() bool {
   position75, tokenIndex75 := position, tokenIndex
   {
position76 := position
   {
   position77, tokenIndex77 := position, tokenIndex
   if !_rules[ruleIDStartCharacter]() {
   goto l78}
   l79:	
   {
   position80, tokenIndex80 := position, tokenIndex
   if !_rules[ruleIDCharacter]() {
   goto l80}
   goto l79
   l80:	
   position, tokenIndex = position80, tokenIndex80
   }
   goto l77
   l78:	
   position, tokenIndex = position77, tokenIndex77
   if !_rules[ruleBackTick]() {
   goto l75}
   {
position81 := position
   if !_rules[ruleIDQuotedCharacter]() {
   goto l75}
   l82:	
   {
   position83, tokenIndex83 := position, tokenIndex
   if !_rules[ruleIDQuotedCharacter]() {
   goto l83}
   goto l82
   l83:	
   position, tokenIndex = position83, tokenIndex83
   }
add(rulePegText, position81)
   }
   if !_rules[ruleBackTick]() {
   goto l75}
   }
   l77:	
add(ruleIdentifier, position76)
   }
   return true
   l75:	
   position, tokenIndex = position75, tokenIndex75
   return false
  },
  /* 16 IdentifierList <- <(<Identifier> Action26 (Comma <Identifier> Action27)*)> */
  func() bool {
   position84, tokenIndex84 := position, tokenIndex
   {
position85 := position
   {
position86 := position
   if !_rules[ruleIdentifier]() {
   goto l84}
add(rulePegText, position86)
   }
   if !_rules[ruleAction26]() {
   goto l84}
   l87:	
   {
   position88, tokenIndex88 := position, tokenIndex
   if !_rules[ruleComma]() {
   goto l88}
   {
position89 := position
   if !_rules[ruleIdentifier]() {
   goto l88}
add(rulePegText, position89)
   }
   if !_rules[ruleAction27]() {
   goto l88}
   goto l87
   l88:	
   position, tokenIndex = position88, tokenIndex88
   }
add(ruleIdentifierList, position85)
   }
   return true
   l84:	
   position, tokenIndex = position84, tokenIndex84
   return false
  },
  /* 17 LiteralStringList <- <(<LiteralString> Action28 (Comma <LiteralString> Action29)*)> */
  func() bool {
   position90, tokenIndex90 := position, tokenIndex
   {
position91 := position
   {
position92 := position
   if !_rules[ruleLiteralString]() {
   goto l90}
add(rulePegText, position92)
   }
   if !_rules[ruleAction28]() {
   goto l90}
   l93:	
   {
   position94, tokenIndex94 := position, tokenIndex
   if !_rules[ruleComma]() {
   goto l94}
   {
position95 := position
   if !_rules[ruleLiteralString]() {
   goto l94}
add(rulePegText, position95)
   }
   if !_rules[ruleAction29]() {
   goto l94}
   goto l93
   l94:	
   position, tokenIndex = position94, tokenIndex94
   }
add(ruleLiteralStringList, position91)
   }
   return true
   l90:	
   position, tokenIndex = position90, tokenIndex90
   return false
  },
  /* 18 IDStartCharacter <- <([A-Z] / [a-z] / '_')> */
  func() bool {
   position96, tokenIndex96 := position, tokenIndex
   {
position97 := position
   {
   position98, tokenIndex98 := position, tokenIndex
   if c := buffer[position]; c < rune('A') || c > rune('Z') {
   goto l99}
position++
   goto l98
   l99:	
   position, tokenIndex = position98, tokenIndex98
   if c := buffer[position]; c < rune('a') || c > rune('z') {
   goto l100}
position++
   goto l98
   l100:	
   position, tokenIndex = position98, tokenIndex98
   if buffer[position] != rune('_') {
   goto l96}
position++
   }
   l98:	
add(ruleIDStartCharacter, position97)
   }
   return true
   l96:	
   position, tokenIndex = position96, tokenIndex96
   return false
  },
  /* 19 IDCharacter <- <([A-Z] / [a-z] / [0-9] / '_' / ':' / '|' / '.' / '-')> */
  func() bool {
   position101, tokenIndex101 := position, tokenIndex
   {
position102 := position
   {
   position103, tokenIndex103 := position, tokenIndex
   if c := buffer[position]; c < rune('A') || c > rune('Z') {
   goto l104}
position++
   goto l103
   l104:	
   position, tokenIndex = position103, tokenIndex103
   if c := buffer[position]; c < rune('a') || c > rune('z') {
   goto l105}
position++
   goto l103
   l105:	
   position, tokenIndex = position103, tokenIndex103
   if c := buffer[position]; c < rune('0') || c > rune('9') {
   goto l106}
position++
   goto l103
   l106:	
   position, tokenIndex = position103, tokenIndex103
   if buffer[position] != rune('_') {
   goto l107}
position++
   goto l103
   l107:	
   position, tokenIndex = position103, tokenIndex103
   if buffer[position] != rune(':') {
   goto l108}
position++
   goto l103
   l108:	
   position, tokenIndex = position103, tokenIndex103
   if buffer[position] != rune('|') {
   goto l109}
position++
   goto l103
   l109:	
   position, tokenIndex = position103, tokenIndex103
   if buffer[position] != rune('.') {
   goto l110}
position++
   goto l103
   l110:	
   position, tokenIndex = position103, tokenIndex103
   if buffer[position] != rune('-') {
   goto l101}
position++
   }
   l103:	
add(ruleIDCharacter, position102)
   }
   return true
   l101:	
   position, tokenIndex = position101, tokenIndex101
   return false
  },
  /* 20 IDQuotedCharacter <- <([A-Z] / [a-z] / [0-9] / '_' / ':' / '|' / '.' / '-' / ' ' / ',' / '$')> */
  func() bool {
   position111, tokenIndex111 := position, tokenIndex
   {
position112 := position
   {
   position113, tokenIndex113 := position, tokenIndex
   if c := buffer[position]; c < rune('A') || c > rune('Z') {
   goto l114}
position++
   goto l113
   l114:	
   position, tokenIndex = position113, tokenIndex113
   if c := buffer[position]; c < rune('a') || c > rune('z') {
   goto l115}
position++
   goto l113
   l115:	
   position, tokenIndex = position113, tokenIndex113
   if c := buffer[position]; c < rune('0') || c > rune('9') {
   goto l116}
position++
   goto l113
   l116:	
   position, tokenIndex = position113, tokenIndex113
   if buffer[position] != rune('_') {
   goto l117}
position++
   goto l113
   l117:	
   position, tokenIndex = position113, tokenIndex113
   if buffer[position] != rune(':') {
   goto l118}
position++
   goto l113
   l118:	
   position, tokenIndex = position113, tokenIndex113
   if buffer[position] != rune('|') {
   goto l119}
position++
   goto l113
   l119:	
   position, tokenIndex = position113, tokenIndex113
   if buffer[position] != rune('.') {
   goto l120}
position++
   goto l113
   l120:	
   position, tokenIndex = position113, tokenIndex113
   if buffer[position] != rune('-') {
   goto l121}
position++
   goto l113
   l121:	
   position, tokenIndex = position113, tokenIndex113
   if buffer[position] != rune(' ') {
   goto l122}
position++
   goto l113
   l122:	
   position, tokenIndex = position113, tokenIndex113
   if buffer[position] != rune(',') {
   goto l123}
position++
   goto l113
   l123:	
   position, tokenIndex = position113, tokenIndex113
   if buffer[position] != rune('$') {
   goto l111}
position++
   }
   l113:	
add(ruleIDQuotedCharacter, position112)
   }
   return true
   l111:	
   position, tokenIndex = position111, tokenIndex111
   return false
  },
  /* 21 LiteralString <- <(Quote <LiteralChar*> Action30 Quote)> */
  func() bool {
   position124, tokenIndex124 := position, tokenIndex
   {
position125 := position
   if !_rules[ruleQuote]() {
   goto l124}
   {
position126 := position
   l127:	
   {
   position128, tokenIndex128 := position, tokenIndex
   if !_rules[ruleLiteralChar]() {
   goto l128}
   goto l127
   l128:	
   position, tokenIndex = position128, tokenIndex128
   }
add(rulePegText, position126)
   }
   if !_rules[ruleAction30]() {
   goto l124}
   if !_rules[ruleQuote]() {
   goto l124}
add(ruleLiteralString, position125)
   }
   return true
   l124:	
   position, tokenIndex = position124, tokenIndex124
   return false
  },
  /* 22 METRICS <- <(('m' / 'M') ('e' / 'E') ('t' / 'T') ('r' / 'R') ('i' / 'I') ('c' / 'C'))> */
  func() bool {
   position129, tokenIndex129 := position, tokenIndex
   {
position130 := position
   {
   position131, tokenIndex131 := position, tokenIndex
   if buffer[position] != rune('m') {
   goto l132}
position++
   goto l131
   l132:	
   position, tokenIndex = position131, tokenIndex131
   if buffer[position] != rune('M') {
   goto l129}
position++
   }
   l131:	
   {
   position133, tokenIndex133 := position, tokenIndex
   if buffer[position] != rune('e') {
   goto l134}
position++
   goto l133
   l134:	
   position, tokenIndex = position133, tokenIndex133
   if buffer[position] != rune('E') {
   goto l129}
position++
   }
   l133:	
   {
   position135, tokenIndex135 := position, tokenIndex
   if buffer[position] != rune('t') {
   goto l136}
position++
   goto l135
   l136:	
   position, tokenIndex = position135, tokenIndex135
   if buffer[position] != rune('T') {
   goto l129}
position++
   }
   l135:	
   {
   position137, tokenIndex137 := position, tokenIndex
   if buffer[position] != rune('r') {
   goto l138}
position++
   goto l137
   l138:	
   position, tokenIndex = position137, tokenIndex137
   if buffer[position] != rune('R') {
   goto l129}
position++
   }
   l137:	
   {
   position139, tokenIndex139 := position, tokenIndex
   if buffer[position] != rune('i') {
   goto l140}
position++
   goto l139
   l140:	
   position, tokenIndex = position139, tokenIndex139
   if buffer[position] != rune('I') {
   goto l129}
position++
   }
   l139:	
   {
   position141, tokenIndex141 := position, tokenIndex
   if buffer[position] != rune('c') {
   goto l142}
position++
   goto l141
   l142:	
   position, tokenIndex = position141, tokenIndex141
   if buffer[position] != rune('C') {
   goto l129}
position++
   }
   l141:	
add(ruleMETRICS, position130)
   }
   return true
   l129:	
   position, tokenIndex = position129, tokenIndex129
   return false
  },
  /* 23 NAME <- <(('n' / 'N') ('a' / 'A') ('m' / 'M') ('e' / 'E'))> */
  func() bool {
   position143, tokenIndex143 := position, tokenIndex
   {
position144 := position
   {
   position145, tokenIndex145 := position, tokenIndex
   if buffer[position] != rune('n') {
   goto l146}
position++
   goto l145
   l146:	
   position, tokenIndex = position145, tokenIndex145
   if buffer[position] != rune('N') {
   goto l143}
position++
   }
   l145:	
   {
   position147, tokenIndex147 := position, tokenIndex
   if buffer[position] != rune('a') {
   goto l148}
position++
   goto l147
   l148:	
   position, tokenIndex = position147, tokenIndex147
   if buffer[position] != rune('A') {
   goto l143}
position++
   }
   l147:	
   {
   position149, tokenIndex149 := position, tokenIndex
   if buffer[position] != rune('m') {
   goto l150}
position++
   goto l149
   l150:	
   position, tokenIndex = position149, tokenIndex149
   if buffer[position] != rune('M') {
   goto l143}
position++
   }
   l149:	
   {
   position151, tokenIndex151 := position, tokenIndex
   if buffer[position] != rune('e') {
   goto l152}
position++
   goto l151
   l152:	
   position, tokenIndex = position151, tokenIndex151
   if buffer[position] != rune('E') {
   goto l143}
position++
   }
   l151:	
add(ruleNAME, position144)
   }
   return true
   l143:	
   position, tokenIndex = position143, tokenIndex143
   return false
  },
  /* 24 REGEX <- <(('r' / 'R') ('e' / 'E') ('g' / 'G') ('e' / 'E') ('x' / 'X'))> */
  func() bool {
   position153, tokenIndex153 := position, tokenIndex
   {
position154 := position
   {
   position155, tokenIndex155 := position, tokenIndex
   if buffer[position] != rune('r') {
   goto l156}
position++
   goto l155
   l156:	
   position, tokenIndex = position155, tokenIndex155
   if buffer[position] != rune('R') {
   goto l153}
position++
   }
   l155:	
   {
   position157, tokenIndex157 := position, tokenIndex
   if buffer[position] != rune('e') {
   goto l158}
position++
   goto l157
   l158:	
   position, tokenIndex = position157, tokenIndex157
   if buffer[position] != rune('E') {
   goto l153}
position++
   }
   l157:	
   {
   position159, tokenIndex159 := position, tokenIndex
   if buffer[position] != rune('g') {
   goto l160}
position++
   goto l159
   l160:	
   position, tokenIndex = position159, tokenIndex159
   if buffer[position] != rune('G') {
   goto l153}
position++
   }
   l159:	
   {
   position161, tokenIndex161 := position, tokenIndex
   if buffer[position] != rune('e') {
   goto l162}
position++
   goto l161
   l162:	
   position, tokenIndex = position161, tokenIndex161
   if buffer[position] != rune('E') {
   goto l153}
position++
   }
   l161:	
   {
   position163, tokenIndex163 := position, tokenIndex
   if buffer[position] != rune('x') {
   goto l164}
position++
   goto l163
   l164:	
   position, tokenIndex = position163, tokenIndex163
   if buffer[position] != rune('X') {
   goto l153}
position++
   }
   l163:	
add(ruleREGEX, position154)
   }
   return true
   l153:	
   position, tokenIndex = position153, tokenIndex153
   return false
  },
  /* 25 RESOURCE <- <(('r' / 'R') ('e' / 'E') ('s' / 'S') ('o' / 'O') ('u' / 'U') ('r' / 'R') ('c' / 'C') ('e' / 'E'))> */
  func() bool {
   position165, tokenIndex165 := position, tokenIndex
   {
position166 := position
   {
   position167, tokenIndex167 := position, tokenIndex
   if buffer[position] != rune('r') {
   goto l168}
position++
   goto l167
   l168:	
   position, tokenIndex = position167, tokenIndex167
   if buffer[position] != rune('R') {
   goto l165}
position++
   }
   l167:	
   {
   position169, tokenIndex169 := position, tokenIndex
   if buffer[position] != rune('e') {
   goto l170}
position++
   goto l169
   l170:	
   position, tokenIndex = position169, tokenIndex169
   if buffer[position] != rune('E') {
   goto l165}
position++
   }
   l169:	
   {
   position171, tokenIndex171 := position, tokenIndex
   if buffer[position] != rune('s') {
   goto l172}
position++
   goto l171
   l172:	
   position, tokenIndex = position171, tokenIndex171
   if buffer[position] != rune('S') {
   goto l165}
position++
   }
   l171:	
   {
   position173, tokenIndex173 := position, tokenIndex
   if buffer[position] != rune('o') {
   goto l174}
position++
   goto l173
   l174:	
   position, tokenIndex = position173, tokenIndex173
   if buffer[position] != rune('O') {
   goto l165}
position++
   }
   l173:	
   {
   position175, tokenIndex175 := position, tokenIndex
   if buffer[position] != rune('u') {
   goto l176}
position++
   goto l175
   l176:	
   position, tokenIndex = position175, tokenIndex175
   if buffer[position] != rune('U') {
   goto l165}
position++
   }
   l175:	
   {
   position177, tokenIndex177 := position, tokenIndex
   if buffer[position] != rune('r') {
   goto l178}
position++
   goto l177
   l178:	
   position, tokenIndex = position177, tokenIndex177
   if buffer[position] != rune('R') {
   goto l165}
position++
   }
   l177:	
   {
   position179, tokenIndex179 := position, tokenIndex
   if buffer[position] != rune('c') {
   goto l180}
position++
   goto l179
   l180:	
   position, tokenIndex = position179, tokenIndex179
   if buffer[position] != rune('C') {
   goto l165}
position++
   }
   l179:	
   {
   position181, tokenIndex181 := position, tokenIndex
   if buffer[position] != rune('e') {
   goto l182}
position++
   goto l181
   l182:	
   position, tokenIndex = position181, tokenIndex181
   if buffer[position] != rune('E') {
   goto l165}
position++
   }
   l181:	
add(ruleRESOURCE, position166)
   }
   return true
   l165:	
   position, tokenIndex = position165, tokenIndex165
   return false
  },
  /* 26 WHERE_HEALTH <- <(('w' / 'W') ('h' / 'H') ('e' / 'E') ('r' / 'R') ('e' / 'E') ('h' / 'H') ('e' / 'E') ('a' / 'A') ('l' / 'L') ('t' / 'T') ('h' / 'H'))> */
  func() bool {
   position183, tokenIndex183 := position, tokenIndex
   {
position184 := position
   {
   position185, tokenIndex185 := position, tokenIndex
   if buffer[position] != rune('w') {
   goto l186}
position++
   goto l185
   l186:	
   position, tokenIndex = position185, tokenIndex185
   if buffer[position] != rune('W') {
   goto l183}
position++
   }
   l185:	
   {
   position187, tokenIndex187 := position, tokenIndex
   if buffer[position] != rune('h') {
   goto l188}
position++
   goto l187
   l188:	
   position, tokenIndex = position187, tokenIndex187
   if buffer[position] != rune('H') {
   goto l183}
position++
   }
   l187:	
   {
   position189, tokenIndex189 := position, tokenIndex
   if buffer[position] != rune('e') {
   goto l190}
position++
   goto l189
   l190:	
   position, tokenIndex = position189, tokenIndex189
   if buffer[position] != rune('E') {
   goto l183}
position++
   }
   l189:	
   {
   position191, tokenIndex191 := position, tokenIndex
   if buffer[position] != rune('r') {
   goto l192}
position++
   goto l191
   l192:	
   position, tokenIndex = position191, tokenIndex191
   if buffer[position] != rune('R') {
   goto l183}
position++
   }
   l191:	
   {
   position193, tokenIndex193 := position, tokenIndex
   if buffer[position] != rune('e') {
   goto l194}
position++
   goto l193
   l194:	
   position, tokenIndex = position193, tokenIndex193
   if buffer[position] != rune('E') {
   goto l183}
position++
   }
   l193:	
   {
   position195, tokenIndex195 := position, tokenIndex
   if buffer[position] != rune('h') {
   goto l196}
position++
   goto l195
   l196:	
   position, tokenIndex = position195, tokenIndex195
   if buffer[position] != rune('H') {
   goto l183}
position++
   }
   l195:	
   {
   position197, tokenIndex197 := position, tokenIndex
   if buffer[position] != rune('e') {
   goto l198}
position++
   goto l197
   l198:	
   position, tokenIndex = position197, tokenIndex197
   if buffer[position] != rune('E') {
   goto l183}
position++
   }
   l197:	
   {
   position199, tokenIndex199 := position, tokenIndex
   if buffer[position] != rune('a') {
   goto l200}
position++
   goto l199
   l200:	
   position, tokenIndex = position199, tokenIndex199
   if buffer[position] != rune('A') {
   goto l183}
position++
   }
   l199:	
   {
   position201, tokenIndex201 := position, tokenIndex
   if buffer[position] != rune('l') {
   goto l202}
position++
   goto l201
   l202:	
   position, tokenIndex = position201, tokenIndex201
   if buffer[position] != rune('L') {
   goto l183}
position++
   }
   l201:	
   {
   position203, tokenIndex203 := position, tokenIndex
   if buffer[position] != rune('t') {
   goto l204}
position++
   goto l203
   l204:	
   position, tokenIndex = position203, tokenIndex203
   if buffer[position] != rune('T') {
   goto l183}
position++
   }
   l203:	
   {
   position205, tokenIndex205 := position, tokenIndex
   if buffer[position] != rune('h') {
   goto l206}
position++
   goto l205
   l206:	
   position, tokenIndex = position205, tokenIndex205
   if buffer[position] != rune('H') {
   goto l183}
position++
   }
   l205:	
add(ruleWHERE_HEALTH, position184)
   }
   return true
   l183:	
   position, tokenIndex = position183, tokenIndex183
   return false
  },
  /* 27 WHERE_STATE <- <(('w' / 'W') ('h' / 'H') ('e' / 'E') ('r' / 'R') ('e' / 'E') ('s' / 'S') ('t' / 'T') ('a' / 'A') ('t' / 'T') ('e' / 'E'))> */
  func() bool {
   position207, tokenIndex207 := position, tokenIndex
   {
position208 := position
   {
   position209, tokenIndex209 := position, tokenIndex
   if buffer[position] != rune('w') {
   goto l210}
position++
   goto l209
   l210:	
   position, tokenIndex = position209, tokenIndex209
   if buffer[position] != rune('W') {
   goto l207}
position++
   }
   l209:	
   {
   position211, tokenIndex211 := position, tokenIndex
   if buffer[position] != rune('h') {
   goto l212}
position++
   goto l211
   l212:	
   position, tokenIndex = position211, tokenIndex211
   if buffer[position] != rune('H') {
   goto l207}
position++
   }
   l211:	
   {
   position213, tokenIndex213 := position, tokenIndex
   if buffer[position] != rune('e') {
   goto l214}
position++
   goto l213
   l214:	
   position, tokenIndex = position213, tokenIndex213
   if buffer[position] != rune('E') {
   goto l207}
position++
   }
   l213:	
   {
   position215, tokenIndex215 := position, tokenIndex
   if buffer[position] != rune('r') {
   goto l216}
position++
   goto l215
   l216:	
   position, tokenIndex = position215, tokenIndex215
   if buffer[position] != rune('R') {
   goto l207}
position++
   }
   l215:	
   {
   position217, tokenIndex217 := position, tokenIndex
   if buffer[position] != rune('e') {
   goto l218}
position++
   goto l217
   l218:	
   position, tokenIndex = position217, tokenIndex217
   if buffer[position] != rune('E') {
   goto l207}
position++
   }
   l217:	
   {
   position219, tokenIndex219 := position, tokenIndex
   if buffer[position] != rune('s') {
   goto l220}
position++
   goto l219
   l220:	
   position, tokenIndex = position219, tokenIndex219
   if buffer[position] != rune('S') {
   goto l207}
position++
   }
   l219:	
   {
   position221, tokenIndex221 := position, tokenIndex
   if buffer[position] != rune('t') {
   goto l222}
position++
   goto l221
   l222:	
   position, tokenIndex = position221, tokenIndex221
   if buffer[position] != rune('T') {
   goto l207}
position++
   }
   l221:	
   {
   position223, tokenIndex223 := position, tokenIndex
   if buffer[position] != rune('a') {
   goto l224}
position++
   goto l223
   l224:	
   position, tokenIndex = position223, tokenIndex223
   if buffer[position] != rune('A') {
   goto l207}
position++
   }
   l223:	
   {
   position225, tokenIndex225 := position, tokenIndex
   if buffer[position] != rune('t') {
   goto l226}
position++
   goto l225
   l226:	
   position, tokenIndex = position225, tokenIndex225
   if buffer[position] != rune('T') {
   goto l207}
position++
   }
   l225:	
   {
   position227, tokenIndex227 := position, tokenIndex
   if buffer[position] != rune('e') {
   goto l228}
position++
   goto l227
   l228:	
   position, tokenIndex = position227, tokenIndex227
   if buffer[position] != rune('E') {
   goto l207}
position++
   }
   l227:	
add(ruleWHERE_STATE, position208)
   }
   return true
   l207:	
   position, tokenIndex = position207, tokenIndex207
   return false
  },
  /* 28 WHERE_STATUS <- <(('w' / 'W') ('h' / 'H') ('e' / 'E') ('r' / 'R') ('e' / 'E') ('s' / 'S') ('t' / 'T') ('a' / 'A') ('t' / 'T') ('u' / 'U') ('s' / 'S'))> */
  func() bool {
   position229, tokenIndex229 := position, tokenIndex
   {
position230 := position
   {
   position231, tokenIndex231 := position, tokenIndex
   if buffer[position] != rune('w') {
   goto l232}
position++
   goto l231
   l232:	
   position, tokenIndex = position231, tokenIndex231
   if buffer[position] != rune('W') {
   goto l229}
position++
   }
   l231:	
   {
   position233, tokenIndex233 := position, tokenIndex
   if buffer[position] != rune('h') {
   goto l234}
position++
   goto l233
   l234:	
   position, tokenIndex = position233, tokenIndex233
   if buffer[position] != rune('H') {
   goto l229}
position++
   }
   l233:	
   {
   position235, tokenIndex235 := position, tokenIndex
   if buffer[position] != rune('e') {
   goto l236}
position++
   goto l235
   l236:	
   position, tokenIndex = position235, tokenIndex235
   if buffer[position] != rune('E') {
   goto l229}
position++
   }
   l235:	
   {
   position237, tokenIndex237 := position, tokenIndex
   if buffer[position] != rune('r') {
   goto l238}
position++
   goto l237
   l238:	
   position, tokenIndex = position237, tokenIndex237
   if buffer[position] != rune('R') {
   goto l229}
position++
   }
   l237:	
   {
   position239, tokenIndex239 := position, tokenIndex
   if buffer[position] != rune('e') {
   goto l240}
position++
   goto l239
   l240:	
   position, tokenIndex = position239, tokenIndex239
   if buffer[position] != rune('E') {
   goto l229}
position++
   }
   l239:	
   {
   position241, tokenIndex241 := position, tokenIndex
   if buffer[position] != rune('s') {
   goto l242}
position++
   goto l241
   l242:	
   position, tokenIndex = position241, tokenIndex241
   if buffer[position] != rune('S') {
   goto l229}
position++
   }
   l241:	
   {
   position243, tokenIndex243 := position, tokenIndex
   if buffer[position] != rune('t') {
   goto l244}
position++
   goto l243
   l244:	
   position, tokenIndex = position243, tokenIndex243
   if buffer[position] != rune('T') {
   goto l229}
position++
   }
   l243:	
   {
   position245, tokenIndex245 := position, tokenIndex
   if buffer[position] != rune('a') {
   goto l246}
position++
   goto l245
   l246:	
   position, tokenIndex = position245, tokenIndex245
   if buffer[position] != rune('A') {
   goto l229}
position++
   }
   l245:	
   {
   position247, tokenIndex247 := position, tokenIndex
   if buffer[position] != rune('t') {
   goto l248}
position++
   goto l247
   l248:	
   position, tokenIndex = position247, tokenIndex247
   if buffer[position] != rune('T') {
   goto l229}
position++
   }
   l247:	
   {
   position249, tokenIndex249 := position, tokenIndex
   if buffer[position] != rune('u') {
   goto l250}
position++
   goto l249
   l250:	
   position, tokenIndex = position249, tokenIndex249
   if buffer[position] != rune('U') {
   goto l229}
position++
   }
   l249:	
   {
   position251, tokenIndex251 := position, tokenIndex
   if buffer[position] != rune('s') {
   goto l252}
position++
   goto l251
   l252:	
   position, tokenIndex = position251, tokenIndex251
   if buffer[position] != rune('S') {
   goto l229}
position++
   }
   l251:	
add(ruleWHERE_STATUS, position230)
   }
   return true
   l229:	
   position, tokenIndex = position229, tokenIndex229
   return false
  },
  /* 29 AND <- <(('a' / 'A') ('n' / 'N') ('d' / 'D'))> */
  func() bool {
   position253, tokenIndex253 := position, tokenIndex
   {
position254 := position
   {
   position255, tokenIndex255 := position, tokenIndex
   if buffer[position] != rune('a') {
   goto l256}
position++
   goto l255
   l256:	
   position, tokenIndex = position255, tokenIndex255
   if buffer[position] != rune('A') {
   goto l253}
position++
   }
   l255:	
   {
   position257, tokenIndex257 := position, tokenIndex
   if buffer[position] != rune('n') {
   goto l258}
position++
   goto l257
   l258:	
   position, tokenIndex = position257, tokenIndex257
   if buffer[position] != rune('N') {
   goto l253}
position++
   }
   l257:	
   {
   position259, tokenIndex259 := position, tokenIndex
   if buffer[position] != rune('d') {
   goto l260}
position++
   goto l259
   l260:	
   position, tokenIndex = position259, tokenIndex259
   if buffer[position] != rune('D') {
   goto l253}
position++
   }
   l259:	
add(ruleAND, position254)
   }
   return true
   l253:	
   position, tokenIndex = position253, tokenIndex253
   return false
  },
  /* 30 OR <- <(('o' / 'O') ('r' / 'R'))> */
  func() bool {
   position261, tokenIndex261 := position, tokenIndex
   {
position262 := position
   {
   position263, tokenIndex263 := position, tokenIndex
   if buffer[position] != rune('o') {
   goto l264}
position++
   goto l263
   l264:	
   position, tokenIndex = position263, tokenIndex263
   if buffer[position] != rune('O') {
   goto l261}
position++
   }
   l263:	
   {
   position265, tokenIndex265 := position, tokenIndex
   if buffer[position] != rune('r') {
   goto l266}
position++
   goto l265
   l266:	
   position, tokenIndex = position265, tokenIndex265
   if buffer[position] != rune('R') {
   goto l261}
position++
   }
   l265:	
add(ruleOR, position262)
   }
   return true
   l261:	
   position, tokenIndex = position261, tokenIndex261
   return false
  },
  /* 31 IN <- <(('i' / 'I') ('n' / 'N'))> */
  func() bool {
   position267, tokenIndex267 := position, tokenIndex
   {
position268 := position
   {
   position269, tokenIndex269 := position, tokenIndex
   if buffer[position] != rune('i') {
   goto l270}
position++
   goto l269
   l270:	
   position, tokenIndex = position269, tokenIndex269
   if buffer[position] != rune('I') {
   goto l267}
position++
   }
   l269:	
   {
   position271, tokenIndex271 := position, tokenIndex
   if buffer[position] != rune('n') {
   goto l272}
position++
   goto l271
   l272:	
   position, tokenIndex = position271, tokenIndex271
   if buffer[position] != rune('N') {
   goto l267}
position++
   }
   l271:	
add(ruleIN, position268)
   }
   return true
   l267:	
   position, tokenIndex = position267, tokenIndex267
   return false
  },
  /* 32 NOT_IN <- <(('n' / 'N') ('o' / 'O') ('t' / 'T') ' ' ('i' / 'I') ('n' / 'N'))> */
  func() bool {
   position273, tokenIndex273 := position, tokenIndex
   {
position274 := position
   {
   position275, tokenIndex275 := position, tokenIndex
   if buffer[position] != rune('n') {
   goto l276}
position++
   goto l275
   l276:	
   position, tokenIndex = position275, tokenIndex275
   if buffer[position] != rune('N') {
   goto l273}
position++
   }
   l275:	
   {
   position277, tokenIndex277 := position, tokenIndex
   if buffer[position] != rune('o') {
   goto l278}
position++
   goto l277
   l278:	
   position, tokenIndex = position277, tokenIndex277
   if buffer[position] != rune('O') {
   goto l273}
position++
   }
   l277:	
   {
   position279, tokenIndex279 := position, tokenIndex
   if buffer[position] != rune('t') {
   goto l280}
position++
   goto l279
   l280:	
   position, tokenIndex = position279, tokenIndex279
   if buffer[position] != rune('T') {
   goto l273}
position++
   }
   l279:	
   if buffer[position] != rune(' ') {
   goto l273}
position++
   {
   position281, tokenIndex281 := position, tokenIndex
   if buffer[position] != rune('i') {
   goto l282}
position++
   goto l281
   l282:	
   position, tokenIndex = position281, tokenIndex281
   if buffer[position] != rune('I') {
   goto l273}
position++
   }
   l281:	
   {
   position283, tokenIndex283 := position, tokenIndex
   if buffer[position] != rune('n') {
   goto l284}
position++
   goto l283
   l284:	
   position, tokenIndex = position283, tokenIndex283
   if buffer[position] != rune('N') {
   goto l273}
position++
   }
   l283:	
add(ruleNOT_IN, position274)
   }
   return true
   l273:	
   position, tokenIndex = position273, tokenIndex273
   return false
  },
  /* 33 CONTAINS <- <(('c' / 'C') ('o' / 'O') ('n' / 'N') ('t' / 'T') ('a' / 'A') ('i' / 'I') ('n' / 'N') ('s' / 'S'))> */
  func() bool {
   position285, tokenIndex285 := position, tokenIndex
   {
position286 := position
   {
   position287, tokenIndex287 := position, tokenIndex
   if buffer[position] != rune('c') {
   goto l288}
position++
   goto l287
   l288:	
   position, tokenIndex = position287, tokenIndex287
   if buffer[position] != rune('C') {
   goto l285}
position++
   }
   l287:	
   {
   position289, tokenIndex289 := position, tokenIndex
   if buffer[position] != rune('o') {
   goto l290}
position++
   goto l289
   l290:	
   position, tokenIndex = position289, tokenIndex289
   if buffer[position] != rune('O') {
   goto l285}
position++
   }
   l289:	
   {
   position291, tokenIndex291 := position, tokenIndex
   if buffer[position] != rune('n') {
   goto l292}
position++
   goto l291
   l292:	
   position, tokenIndex = position291, tokenIndex291
   if buffer[position] != rune('N') {
   goto l285}
position++
   }
   l291:	
   {
   position293, tokenIndex293 := position, tokenIndex
   if buffer[position] != rune('t') {
   goto l294}
position++
   goto l293
   l294:	
   position, tokenIndex = position293, tokenIndex293
   if buffer[position] != rune('T') {
   goto l285}
position++
   }
   l293:	
   {
   position295, tokenIndex295 := position, tokenIndex
   if buffer[position] != rune('a') {
   goto l296}
position++
   goto l295
   l296:	
   position, tokenIndex = position295, tokenIndex295
   if buffer[position] != rune('A') {
   goto l285}
position++
   }
   l295:	
   {
   position297, tokenIndex297 := position, tokenIndex
   if buffer[position] != rune('i') {
   goto l298}
position++
   goto l297
   l298:	
   position, tokenIndex = position297, tokenIndex297
   if buffer[position] != rune('I') {
   goto l285}
position++
   }
   l297:	
   {
   position299, tokenIndex299 := position, tokenIndex
   if buffer[position] != rune('n') {
   goto l300}
position++
   goto l299
   l300:	
   position, tokenIndex = position299, tokenIndex299
   if buffer[position] != rune('N') {
   goto l285}
position++
   }
   l299:	
   {
   position301, tokenIndex301 := position, tokenIndex
   if buffer[position] != rune('s') {
   goto l302}
position++
   goto l301
   l302:	
   position, tokenIndex = position301, tokenIndex301
   if buffer[position] != rune('S') {
   goto l285}
position++
   }
   l301:	
add(ruleCONTAINS, position286)
   }
   return true
   l285:	
   position, tokenIndex = position285, tokenIndex285
   return false
  },
  /* 34 STARTS_WITH <- <(('s' / 'S') ('t' / 'T') ('a' / 'A') ('r' / 'R') ('t' / 'T') ('s' / 'S') '_' ('w' / 'W') ('i' / 'I') ('t' / 'T') ('h' / 'H'))> */
  func() bool {
   position303, tokenIndex303 := position, tokenIndex
   {
position304 := position
   {
   position305, tokenIndex305 := position, tokenIndex
   if buffer[position] != rune('s') {
   goto l306}
position++
   goto l305
   l306:	
   position, tokenIndex = position305, tokenIndex305
   if buffer[position] != rune('S') {
   goto l303}
position++
   }
   l305:	
   {
   position307, tokenIndex307 := position, tokenIndex
   if buffer[position] != rune('t') {
   goto l308}
position++
   goto l307
   l308:	
   position, tokenIndex = position307, tokenIndex307
   if buffer[position] != rune('T') {
   goto l303}
position++
   }
   l307:	
   {
   position309, tokenIndex309 := position, tokenIndex
   if buffer[position] != rune('a') {
   goto l310}
position++
   goto l309
   l310:	
   position, tokenIndex = position309, tokenIndex309
   if buffer[position] != rune('A') {
   goto l303}
position++
   }
   l309:	
   {
   position311, tokenIndex311 := position, tokenIndex
   if buffer[position] != rune('r') {
   goto l312}
position++
   goto l311
   l312:	
   position, tokenIndex = position311, tokenIndex311
   if buffer[position] != rune('R') {
   goto l303}
position++
   }
   l311:	
   {
   position313, tokenIndex313 := position, tokenIndex
   if buffer[position] != rune('t') {
   goto l314}
position++
   goto l313
   l314:	
   position, tokenIndex = position313, tokenIndex313
   if buffer[position] != rune('T') {
   goto l303}
position++
   }
   l313:	
   {
   position315, tokenIndex315 := position, tokenIndex
   if buffer[position] != rune('s') {
   goto l316}
position++
   goto l315
   l316:	
   position, tokenIndex = position315, tokenIndex315
   if buffer[position] != rune('S') {
   goto l303}
position++
   }
   l315:	
   if buffer[position] != rune('_') {
   goto l303}
position++
   {
   position317, tokenIndex317 := position, tokenIndex
   if buffer[position] != rune('w') {
   goto l318}
position++
   goto l317
   l318:	
   position, tokenIndex = position317, tokenIndex317
   if buffer[position] != rune('W') {
   goto l303}
position++
   }
   l317:	
   {
   position319, tokenIndex319 := position, tokenIndex
   if buffer[position] != rune('i') {
   goto l320}
position++
   goto l319
   l320:	
   position, tokenIndex = position319, tokenIndex319
   if buffer[position] != rune('I') {
   goto l303}
position++
   }
   l319:	
   {
   position321, tokenIndex321 := position, tokenIndex
   if buffer[position] != rune('t') {
   goto l322}
position++
   goto l321
   l322:	
   position, tokenIndex = position321, tokenIndex321
   if buffer[position] != rune('T') {
   goto l303}
position++
   }
   l321:	
   {
   position323, tokenIndex323 := position, tokenIndex
   if buffer[position] != rune('h') {
   goto l324}
position++
   goto l323
   l324:	
   position, tokenIndex = position323, tokenIndex323
   if buffer[position] != rune('H') {
   goto l303}
position++
   }
   l323:	
add(ruleSTARTS_WITH, position304)
   }
   return true
   l303:	
   position, tokenIndex = position303, tokenIndex303
   return false
  },
  /* 35 ENDS_WITH <- <(('e' / 'E') ('n' / 'N') ('d' / 'D') ('s' / 'S') '_' ('w' / 'W') ('i' / 'I') ('t' / 'T') ('h' / 'H'))> */
  func() bool {
   position325, tokenIndex325 := position, tokenIndex
   {
position326 := position
   {
   position327, tokenIndex327 := position, tokenIndex
   if buffer[position] != rune('e') {
   goto l328}
position++
   goto l327
   l328:	
   position, tokenIndex = position327, tokenIndex327
   if buffer[position] != rune('E') {
   goto l325}
position++
   }
   l327:	
   {
   position329, tokenIndex329 := position, tokenIndex
   if buffer[position] != rune('n') {
   goto l330}
position++
   goto l329
   l330:	
   position, tokenIndex = position329, tokenIndex329
   if buffer[position] != rune('N') {
   goto l325}
position++
   }
   l329:	
   {
   position331, tokenIndex331 := position, tokenIndex
   if buffer[position] != rune('d') {
   goto l332}
position++
   goto l331
   l332:	
   position, tokenIndex = position331, tokenIndex331
   if buffer[position] != rune('D') {
   goto l325}
position++
   }
   l331:	
   {
   position333, tokenIndex333 := position, tokenIndex
   if buffer[position] != rune('s') {
   goto l334}
position++
   goto l333
   l334:	
   position, tokenIndex = position333, tokenIndex333
   if buffer[position] != rune('S') {
   goto l325}
position++
   }
   l333:	
   if buffer[position] != rune('_') {
   goto l325}
position++
   {
   position335, tokenIndex335 := position, tokenIndex
   if buffer[position] != rune('w') {
   goto l336}
position++
   goto l335
   l336:	
   position, tokenIndex = position335, tokenIndex335
   if buffer[position] != rune('W') {
   goto l325}
position++
   }
   l335:	
   {
   position337, tokenIndex337 := position, tokenIndex
   if buffer[position] != rune('i') {
   goto l338}
position++
   goto l337
   l338:	
   position, tokenIndex = position337, tokenIndex337
   if buffer[position] != rune('I') {
   goto l325}
position++
   }
   l337:	
   {
   position339, tokenIndex339 := position, tokenIndex
   if buffer[position] != rune('t') {
   goto l340}
position++
   goto l339
   l340:	
   position, tokenIndex = position339, tokenIndex339
   if buffer[position] != rune('T') {
   goto l325}
position++
   }
   l339:	
   {
   position341, tokenIndex341 := position, tokenIndex
   if buffer[position] != rune('h') {
   goto l342}
position++
   goto l341
   l342:	
   position, tokenIndex = position341, tokenIndex341
   if buffer[position] != rune('H') {
   goto l325}
position++
   }
   l341:	
add(ruleENDS_WITH, position326)
   }
   return true
   l325:	
   position, tokenIndex = position325, tokenIndex325
   return false
  },
  /* 36 NOT_STARTS_WITH <- <(('n' / 'N') ('o' / 'O') ('t' / 'T') ' ' ('s' / 'S') ('t' / 'T') ('a' / 'A') ('r' / 'R') ('t' / 'T') ('s' / 'S') '_' ('w' / 'W') ('i' / 'I') ('t' / 'T') ('h' / 'H'))> */
  func() bool {
   position343, tokenIndex343 := position, tokenIndex
   {
position344 := position
   {
   position345, tokenIndex345 := position, tokenIndex
   if buffer[position] != rune('n') {
   goto l346}
position++
   goto l345
   l346:	
   position, tokenIndex = position345, tokenIndex345
   if buffer[position] != rune('N') {
   goto l343}
position++
   }
   l345:	
   {
   position347, tokenIndex347 := position, tokenIndex
   if buffer[position] != rune('o') {
   goto l348}
position++
   goto l347
   l348:	
   position, tokenIndex = position347, tokenIndex347
   if buffer[position] != rune('O') {
   goto l343}
position++
   }
   l347:	
   {
   position349, tokenIndex349 := position, tokenIndex
   if buffer[position] != rune('t') {
   goto l350}
position++
   goto l349
   l350:	
   position, tokenIndex = position349, tokenIndex349
   if buffer[position] != rune('T') {
   goto l343}
position++
   }
   l349:	
   if buffer[position] != rune(' ') {
   goto l343}
position++
   {
   position351, tokenIndex351 := position, tokenIndex
   if buffer[position] != rune('s') {
   goto l352}
position++
   goto l351
   l352:	
   position, tokenIndex = position351, tokenIndex351
   if buffer[position] != rune('S') {
   goto l343}
position++
   }
   l351:	
   {
   position353, tokenIndex353 := position, tokenIndex
   if buffer[position] != rune('t') {
   goto l354}
position++
   goto l353
   l354:	
   position, tokenIndex = position353, tokenIndex353
   if buffer[position] != rune('T') {
   goto l343}
position++
   }
   l353:	
   {
   position355, tokenIndex355 := position, tokenIndex
   if buffer[position] != rune('a') {
   goto l356}
position++
   goto l355
   l356:	
   position, tokenIndex = position355, tokenIndex355
   if buffer[position] != rune('A') {
   goto l343}
position++
   }
   l355:	
   {
   position357, tokenIndex357 := position, tokenIndex
   if buffer[position] != rune('r') {
   goto l358}
position++
   goto l357
   l358:	
   position, tokenIndex = position357, tokenIndex357
   if buffer[position] != rune('R') {
   goto l343}
position++
   }
   l357:	
   {
   position359, tokenIndex359 := position, tokenIndex
   if buffer[position] != rune('t') {
   goto l360}
position++
   goto l359
   l360:	
   position, tokenIndex = position359, tokenIndex359
   if buffer[position] != rune('T') {
   goto l343}
position++
   }
   l359:	
   {
   position361, tokenIndex361 := position, tokenIndex
   if buffer[position] != rune('s') {
   goto l362}
position++
   goto l361
   l362:	
   position, tokenIndex = position361, tokenIndex361
   if buffer[position] != rune('S') {
   goto l343}
position++
   }
   l361:	
   if buffer[position] != rune('_') {
   goto l343}
position++
   {
   position363, tokenIndex363 := position, tokenIndex
   if buffer[position] != rune('w') {
   goto l364}
position++
   goto l363
   l364:	
   position, tokenIndex = position363, tokenIndex363
   if buffer[position] != rune('W') {
   goto l343}
position++
   }
   l363:	
   {
   position365, tokenIndex365 := position, tokenIndex
   if buffer[position] != rune('i') {
   goto l366}
position++
   goto l365
   l366:	
   position, tokenIndex = position365, tokenIndex365
   if buffer[position] != rune('I') {
   goto l343}
position++
   }
   l365:	
   {
   position367, tokenIndex367 := position, tokenIndex
   if buffer[position] != rune('t') {
   goto l368}
position++
   goto l367
   l368:	
   position, tokenIndex = position367, tokenIndex367
   if buffer[position] != rune('T') {
   goto l343}
position++
   }
   l367:	
   {
   position369, tokenIndex369 := position, tokenIndex
   if buffer[position] != rune('h') {
   goto l370}
position++
   goto l369
   l370:	
   position, tokenIndex = position369, tokenIndex369
   if buffer[position] != rune('H') {
   goto l343}
position++
   }
   l369:	
add(ruleNOT_STARTS_WITH, position344)
   }
   return true
   l343:	
   position, tokenIndex = position343, tokenIndex343
   return false
  },
  /* 37 NOT_ENDS_WITH <- <(('n' / 'N') ('o' / 'O') ('t' / 'T') ' ' ('e' / 'E') ('n' / 'N') ('d' / 'D') ('s' / 'S') '_' ('w' / 'W') ('i' / 'I') ('t' / 'T') ('h' / 'H'))> */
  func() bool {
   position371, tokenIndex371 := position, tokenIndex
   {
position372 := position
   {
   position373, tokenIndex373 := position, tokenIndex
   if buffer[position] != rune('n') {
   goto l374}
position++
   goto l373
   l374:	
   position, tokenIndex = position373, tokenIndex373
   if buffer[position] != rune('N') {
   goto l371}
position++
   }
   l373:	
   {
   position375, tokenIndex375 := position, tokenIndex
   if buffer[position] != rune('o') {
   goto l376}
position++
   goto l375
   l376:	
   position, tokenIndex = position375, tokenIndex375
   if buffer[position] != rune('O') {
   goto l371}
position++
   }
   l375:	
   {
   position377, tokenIndex377 := position, tokenIndex
   if buffer[position] != rune('t') {
   goto l378}
position++
   goto l377
   l378:	
   position, tokenIndex = position377, tokenIndex377
   if buffer[position] != rune('T') {
   goto l371}
position++
   }
   l377:	
   if buffer[position] != rune(' ') {
   goto l371}
position++
   {
   position379, tokenIndex379 := position, tokenIndex
   if buffer[position] != rune('e') {
   goto l380}
position++
   goto l379
   l380:	
   position, tokenIndex = position379, tokenIndex379
   if buffer[position] != rune('E') {
   goto l371}
position++
   }
   l379:	
   {
   position381, tokenIndex381 := position, tokenIndex
   if buffer[position] != rune('n') {
   goto l382}
position++
   goto l381
   l382:	
   position, tokenIndex = position381, tokenIndex381
   if buffer[position] != rune('N') {
   goto l371}
position++
   }
   l381:	
   {
   position383, tokenIndex383 := position, tokenIndex
   if buffer[position] != rune('d') {
   goto l384}
position++
   goto l383
   l384:	
   position, tokenIndex = position383, tokenIndex383
   if buffer[position] != rune('D') {
   goto l371}
position++
   }
   l383:	
   {
   position385, tokenIndex385 := position, tokenIndex
   if buffer[position] != rune('s') {
   goto l386}
position++
   goto l385
   l386:	
   position, tokenIndex = position385, tokenIndex385
   if buffer[position] != rune('S') {
   goto l371}
position++
   }
   l385:	
   if buffer[position] != rune('_') {
   goto l371}
position++
   {
   position387, tokenIndex387 := position, tokenIndex
   if buffer[position] != rune('w') {
   goto l388}
position++
   goto l387
   l388:	
   position, tokenIndex = position387, tokenIndex387
   if buffer[position] != rune('W') {
   goto l371}
position++
   }
   l387:	
   {
   position389, tokenIndex389 := position, tokenIndex
   if buffer[position] != rune('i') {
   goto l390}
position++
   goto l389
   l390:	
   position, tokenIndex = position389, tokenIndex389
   if buffer[position] != rune('I') {
   goto l371}
position++
   }
   l389:	
   {
   position391, tokenIndex391 := position, tokenIndex
   if buffer[position] != rune('t') {
   goto l392}
position++
   goto l391
   l392:	
   position, tokenIndex = position391, tokenIndex391
   if buffer[position] != rune('T') {
   goto l371}
position++
   }
   l391:	
   {
   position393, tokenIndex393 := position, tokenIndex
   if buffer[position] != rune('h') {
   goto l394}
position++
   goto l393
   l394:	
   position, tokenIndex = position393, tokenIndex393
   if buffer[position] != rune('H') {
   goto l371}
position++
   }
   l393:	
add(ruleNOT_ENDS_WITH, position372)
   }
   return true
   l371:	
   position, tokenIndex = position371, tokenIndex371
   return false
  },
  /* 38 NOT_CONTAINS <- <(('n' / 'N') ('o' / 'O') ('t' / 'T') ' ' ('c' / 'C') ('o' / 'O') ('n' / 'N') ('t' / 'T') ('a' / 'A') ('i' / 'I') ('n' / 'N') ('s' / 'S'))> */
  func() bool {
   position395, tokenIndex395 := position, tokenIndex
   {
position396 := position
   {
   position397, tokenIndex397 := position, tokenIndex
   if buffer[position] != rune('n') {
   goto l398}
position++
   goto l397
   l398:	
   position, tokenIndex = position397, tokenIndex397
   if buffer[position] != rune('N') {
   goto l395}
position++
   }
   l397:	
   {
   position399, tokenIndex399 := position, tokenIndex
   if buffer[position] != rune('o') {
   goto l400}
position++
   goto l399
   l400:	
   position, tokenIndex = position399, tokenIndex399
   if buffer[position] != rune('O') {
   goto l395}
position++
   }
   l399:	
   {
   position401, tokenIndex401 := position, tokenIndex
   if buffer[position] != rune('t') {
   goto l402}
position++
   goto l401
   l402:	
   position, tokenIndex = position401, tokenIndex401
   if buffer[position] != rune('T') {
   goto l395}
position++
   }
   l401:	
   if buffer[position] != rune(' ') {
   goto l395}
position++
   {
   position403, tokenIndex403 := position, tokenIndex
   if buffer[position] != rune('c') {
   goto l404}
position++
   goto l403
   l404:	
   position, tokenIndex = position403, tokenIndex403
   if buffer[position] != rune('C') {
   goto l395}
position++
   }
   l403:	
   {
   position405, tokenIndex405 := position, tokenIndex
   if buffer[position] != rune('o') {
   goto l406}
position++
   goto l405
   l406:	
   position, tokenIndex = position405, tokenIndex405
   if buffer[position] != rune('O') {
   goto l395}
position++
   }
   l405:	
   {
   position407, tokenIndex407 := position, tokenIndex
   if buffer[position] != rune('n') {
   goto l408}
position++
   goto l407
   l408:	
   position, tokenIndex = position407, tokenIndex407
   if buffer[position] != rune('N') {
   goto l395}
position++
   }
   l407:	
   {
   position409, tokenIndex409 := position, tokenIndex
   if buffer[position] != rune('t') {
   goto l410}
position++
   goto l409
   l410:	
   position, tokenIndex = position409, tokenIndex409
   if buffer[position] != rune('T') {
   goto l395}
position++
   }
   l409:	
   {
   position411, tokenIndex411 := position, tokenIndex
   if buffer[position] != rune('a') {
   goto l412}
position++
   goto l411
   l412:	
   position, tokenIndex = position411, tokenIndex411
   if buffer[position] != rune('A') {
   goto l395}
position++
   }
   l411:	
   {
   position413, tokenIndex413 := position, tokenIndex
   if buffer[position] != rune('i') {
   goto l414}
position++
   goto l413
   l414:	
   position, tokenIndex = position413, tokenIndex413
   if buffer[position] != rune('I') {
   goto l395}
position++
   }
   l413:	
   {
   position415, tokenIndex415 := position, tokenIndex
   if buffer[position] != rune('n') {
   goto l416}
position++
   goto l415
   l416:	
   position, tokenIndex = position415, tokenIndex415
   if buffer[position] != rune('N') {
   goto l395}
position++
   }
   l415:	
   {
   position417, tokenIndex417 := position, tokenIndex
   if buffer[position] != rune('s') {
   goto l418}
position++
   goto l417
   l418:	
   position, tokenIndex = position417, tokenIndex417
   if buffer[position] != rune('S') {
   goto l395}
position++
   }
   l417:	
add(ruleNOT_CONTAINS, position396)
   }
   return true
   l395:	
   position, tokenIndex = position395, tokenIndex395
   return false
  },
  /* 39 REGEX <- (('r' / 'R') ('e' / 'E') ('g' / 'G') ('e' / 'E') ('x' / 'X')) */
  func() bool {
   position419, tokenIndex419 := position, tokenIndex
   {
   position420, tokenIndex420 := position, tokenIndex
   if buffer[position] != rune('r') {
   goto l421}
position++
   goto l420
   l421:	
   position, tokenIndex = position420, tokenIndex420
   if buffer[position] != rune('R') {
   goto l419}
position++
   }
   l420:	
   {
   position422, tokenIndex422 := position, tokenIndex
   if buffer[position] != rune('e') {
   goto l423}
position++
   goto l422
   l423:	
   position, tokenIndex = position422, tokenIndex422
   if buffer[position] != rune('E') {
   goto l419}
position++
   }
   l422:	
   {
   position424, tokenIndex424 := position, tokenIndex
   if buffer[position] != rune('g') {
   goto l425}
position++
   goto l424
   l425:	
   position, tokenIndex = position424, tokenIndex424
   if buffer[position] != rune('G') {
   goto l419}
position++
   }
   l424:	
   {
   position426, tokenIndex426 := position, tokenIndex
   if buffer[position] != rune('e') {
   goto l427}
position++
   goto l426
   l427:	
   position, tokenIndex = position426, tokenIndex426
   if buffer[position] != rune('E') {
   goto l419}
position++
   }
   l426:	
   {
   position428, tokenIndex428 := position, tokenIndex
   if buffer[position] != rune('x') {
   goto l429}
position++
   goto l428
   l429:	
   position, tokenIndex = position428, tokenIndex428
   if buffer[position] != rune('X') {
   goto l419}
position++
   }
   l428:	
   return true
   l419:	
   position, tokenIndex = position419, tokenIndex419
   return false
  },
  /* 40 NOT_REGEX <- <(('n' / 'N') ('o' / 'O') ('t' / 'T') ' ' ('r' / 'R') ('e' / 'E') ('g' / 'G') ('e' / 'E') ('x' / 'X'))> */
  func() bool {
   position430, tokenIndex430 := position, tokenIndex
   {
position431 := position
   {
   position432, tokenIndex432 := position, tokenIndex
   if buffer[position] != rune('n') {
   goto l433}
position++
   goto l432
   l433:	
   position, tokenIndex = position432, tokenIndex432
   if buffer[position] != rune('N') {
   goto l430}
position++
   }
   l432:	
   {
   position434, tokenIndex434 := position, tokenIndex
   if buffer[position] != rune('o') {
   goto l435}
position++
   goto l434
   l435:	
   position, tokenIndex = position434, tokenIndex434
   if buffer[position] != rune('O') {
   goto l430}
position++
   }
   l434:	
   {
   position436, tokenIndex436 := position, tokenIndex
   if buffer[position] != rune('t') {
   goto l437}
position++
   goto l436
   l437:	
   position, tokenIndex = position436, tokenIndex436
   if buffer[position] != rune('T') {
   goto l430}
position++
   }
   l436:	
   if buffer[position] != rune(' ') {
   goto l430}
position++
   {
   position438, tokenIndex438 := position, tokenIndex
   if buffer[position] != rune('r') {
   goto l439}
position++
   goto l438
   l439:	
   position, tokenIndex = position438, tokenIndex438
   if buffer[position] != rune('R') {
   goto l430}
position++
   }
   l438:	
   {
   position440, tokenIndex440 := position, tokenIndex
   if buffer[position] != rune('e') {
   goto l441}
position++
   goto l440
   l441:	
   position, tokenIndex = position440, tokenIndex440
   if buffer[position] != rune('E') {
   goto l430}
position++
   }
   l440:	
   {
   position442, tokenIndex442 := position, tokenIndex
   if buffer[position] != rune('g') {
   goto l443}
position++
   goto l442
   l443:	
   position, tokenIndex = position442, tokenIndex442
   if buffer[position] != rune('G') {
   goto l430}
position++
   }
   l442:	
   {
   position444, tokenIndex444 := position, tokenIndex
   if buffer[position] != rune('e') {
   goto l445}
position++
   goto l444
   l445:	
   position, tokenIndex = position444, tokenIndex444
   if buffer[position] != rune('E') {
   goto l430}
position++
   }
   l444:	
   {
   position446, tokenIndex446 := position, tokenIndex
   if buffer[position] != rune('x') {
   goto l447}
position++
   goto l446
   l447:	
   position, tokenIndex = position446, tokenIndex446
   if buffer[position] != rune('X') {
   goto l430}
position++
   }
   l446:	
add(ruleNOT_REGEX, position431)
   }
   return true
   l430:	
   position, tokenIndex = position430, tokenIndex430
   return false
  },
  /* 41 EXISTS <- <(('e' / 'E') ('x' / 'X') ('i' / 'I') ('s' / 'S') ('t' / 'T') ('s' / 'S'))> */
  func() bool {
   position448, tokenIndex448 := position, tokenIndex
   {
position449 := position
   {
   position450, tokenIndex450 := position, tokenIndex
   if buffer[position] != rune('e') {
   goto l451}
position++
   goto l450
   l451:	
   position, tokenIndex = position450, tokenIndex450
   if buffer[position] != rune('E') {
   goto l448}
position++
   }
   l450:	
   {
   position452, tokenIndex452 := position, tokenIndex
   if buffer[position] != rune('x') {
   goto l453}
position++
   goto l452
   l453:	
   position, tokenIndex = position452, tokenIndex452
   if buffer[position] != rune('X') {
   goto l448}
position++
   }
   l452:	
   {
   position454, tokenIndex454 := position, tokenIndex
   if buffer[position] != rune('i') {
   goto l455}
position++
   goto l454
   l455:	
   position, tokenIndex = position454, tokenIndex454
   if buffer[position] != rune('I') {
   goto l448}
position++
   }
   l454:	
   {
   position456, tokenIndex456 := position, tokenIndex
   if buffer[position] != rune('s') {
   goto l457}
position++
   goto l456
   l457:	
   position, tokenIndex = position456, tokenIndex456
   if buffer[position] != rune('S') {
   goto l448}
position++
   }
   l456:	
   {
   position458, tokenIndex458 := position, tokenIndex
   if buffer[position] != rune('t') {
   goto l459}
position++
   goto l458
   l459:	
   position, tokenIndex = position458, tokenIndex458
   if buffer[position] != rune('T') {
   goto l448}
position++
   }
   l458:	
   {
   position460, tokenIndex460 := position, tokenIndex
   if buffer[position] != rune('s') {
   goto l461}
position++
   goto l460
   l461:	
   position, tokenIndex = position460, tokenIndex460
   if buffer[position] != rune('S') {
   goto l448}
position++
   }
   l460:	
add(ruleEXISTS, position449)
   }
   return true
   l448:	
   position, tokenIndex = position448, tokenIndex448
   return false
  },
  /* 42 NOT_EXISTS <- <(('n' / 'N') ('o' / 'O') ('t' / 'T') ' ' ('e' / 'E') ('x' / 'X') ('i' / 'I') ('s' / 'S') ('t' / 'T') ('s' / 'S'))> */
  func() bool {
   position462, tokenIndex462 := position, tokenIndex
   {
position463 := position
   {
   position464, tokenIndex464 := position, tokenIndex
   if buffer[position] != rune('n') {
   goto l465}
position++
   goto l464
   l465:	
   position, tokenIndex = position464, tokenIndex464
   if buffer[position] != rune('N') {
   goto l462}
position++
   }
   l464:	
   {
   position466, tokenIndex466 := position, tokenIndex
   if buffer[position] != rune('o') {
   goto l467}
position++
   goto l466
   l467:	
   position, tokenIndex = position466, tokenIndex466
   if buffer[position] != rune('O') {
   goto l462}
position++
   }
   l466:	
   {
   position468, tokenIndex468 := position, tokenIndex
   if buffer[position] != rune('t') {
   goto l469}
position++
   goto l468
   l469:	
   position, tokenIndex = position468, tokenIndex468
   if buffer[position] != rune('T') {
   goto l462}
position++
   }
   l468:	
   if buffer[position] != rune(' ') {
   goto l462}
position++
   {
   position470, tokenIndex470 := position, tokenIndex
   if buffer[position] != rune('e') {
   goto l471}
position++
   goto l470
   l471:	
   position, tokenIndex = position470, tokenIndex470
   if buffer[position] != rune('E') {
   goto l462}
position++
   }
   l470:	
   {
   position472, tokenIndex472 := position, tokenIndex
   if buffer[position] != rune('x') {
   goto l473}
position++
   goto l472
   l473:	
   position, tokenIndex = position472, tokenIndex472
   if buffer[position] != rune('X') {
   goto l462}
position++
   }
   l472:	
   {
   position474, tokenIndex474 := position, tokenIndex
   if buffer[position] != rune('i') {
   goto l475}
position++
   goto l474
   l475:	
   position, tokenIndex = position474, tokenIndex474
   if buffer[position] != rune('I') {
   goto l462}
position++
   }
   l474:	
   {
   position476, tokenIndex476 := position, tokenIndex
   if buffer[position] != rune('s') {
   goto l477}
position++
   goto l476
   l477:	
   position, tokenIndex = position476, tokenIndex476
   if buffer[position] != rune('S') {
   goto l462}
position++
   }
   l476:	
   {
   position478, tokenIndex478 := position, tokenIndex
   if buffer[position] != rune('t') {
   goto l479}
position++
   goto l478
   l479:	
   position, tokenIndex = position478, tokenIndex478
   if buffer[position] != rune('T') {
   goto l462}
position++
   }
   l478:	
   {
   position480, tokenIndex480 := position, tokenIndex
   if buffer[position] != rune('s') {
   goto l481}
position++
   goto l480
   l481:	
   position, tokenIndex = position480, tokenIndex480
   if buffer[position] != rune('S') {
   goto l462}
position++
   }
   l480:	
add(ruleNOT_EXISTS, position463)
   }
   return true
   l462:	
   position, tokenIndex = position462, tokenIndex462
   return false
  },
  /* 43 GT <- <'>'> */
  func() bool {
   position482, tokenIndex482 := position, tokenIndex
   {
position483 := position
   if buffer[position] != rune('>') {
   goto l482}
position++
add(ruleGT, position483)
   }
   return true
   l482:	
   position, tokenIndex = position482, tokenIndex482
   return false
  },
  /* 44 LT <- <'<'> */
  func() bool {
   position484, tokenIndex484 := position, tokenIndex
   {
position485 := position
   if buffer[position] != rune('<') {
   goto l484}
position++
add(ruleLT, position485)
   }
   return true
   l484:	
   position, tokenIndex = position484, tokenIndex484
   return false
  },
  /* 45 GTE <- <('>' '=')> */
  func() bool {
   position486, tokenIndex486 := position, tokenIndex
   {
position487 := position
   if buffer[position] != rune('>') {
   goto l486}
position++
   if buffer[position] != rune('=') {
   goto l486}
position++
add(ruleGTE, position487)
   }
   return true
   l486:	
   position, tokenIndex = position486, tokenIndex486
   return false
  },
  /* 46 LTE <- <('<' '=')> */
  func() bool {
   position488, tokenIndex488 := position, tokenIndex
   {
position489 := position
   if buffer[position] != rune('<') {
   goto l488}
position++
   if buffer[position] != rune('=') {
   goto l488}
position++
add(ruleLTE, position489)
   }
   return true
   l488:	
   position, tokenIndex = position488, tokenIndex488
   return false
  },
  /* 47 EQ <- <'='> */
  func() bool {
   position490, tokenIndex490 := position, tokenIndex
   {
position491 := position
   if buffer[position] != rune('=') {
   goto l490}
position++
add(ruleEQ, position491)
   }
   return true
   l490:	
   position, tokenIndex = position490, tokenIndex490
   return false
  },
  /* 48 NE <- <('!' '=')> */
  func() bool {
   position492, tokenIndex492 := position, tokenIndex
   {
position493 := position
   if buffer[position] != rune('!') {
   goto l492}
position++
   if buffer[position] != rune('=') {
   goto l492}
position++
add(ruleNE, position493)
   }
   return true
   l492:	
   position, tokenIndex = position492, tokenIndex492
   return false
  },
  /* 49 Quote <- <'"'> */
  func() bool {
   position494, tokenIndex494 := position, tokenIndex
   {
position495 := position
   if buffer[position] != rune('"') {
   goto l494}
position++
add(ruleQuote, position495)
   }
   return true
   l494:	
   position, tokenIndex = position494, tokenIndex494
   return false
  },
  /* 50 Comma <- <(_ ',' _)> */
  func() bool {
   position496, tokenIndex496 := position, tokenIndex
   {
position497 := position
   if !_rules[rule_]() {
   goto l496}
   if buffer[position] != rune(',') {
   goto l496}
position++
   if !_rules[rule_]() {
   goto l496}
add(ruleComma, position497)
   }
   return true
   l496:	
   position, tokenIndex = position496, tokenIndex496
   return false
  },
  /* 51 BackTick <- <'`'> */
  func() bool {
   position498, tokenIndex498 := position, tokenIndex
   {
position499 := position
   if buffer[position] != rune('`') {
   goto l498}
position++
add(ruleBackTick, position499)
   }
   return true
   l498:	
   position, tokenIndex = position498, tokenIndex498
   return false
  },
  /* 52 Dot <- <(_ '.' _)> */
  func() bool {
   position500, tokenIndex500 := position, tokenIndex
   {
position501 := position
   if !_rules[rule_]() {
   goto l500}
   if buffer[position] != rune('.') {
   goto l500}
position++
   if !_rules[rule_]() {
   goto l500}
add(ruleDot, position501)
   }
   return true
   l500:	
   position, tokenIndex = position500, tokenIndex500
   return false
  },
  /* 53 LP <- <(_ '(' _)> */
  func() bool {
   position502, tokenIndex502 := position, tokenIndex
   {
position503 := position
   if !_rules[rule_]() {
   goto l502}
   if buffer[position] != rune('(') {
   goto l502}
position++
   if !_rules[rule_]() {
   goto l502}
add(ruleLP, position503)
   }
   return true
   l502:	
   position, tokenIndex = position502, tokenIndex502
   return false
  },
  /* 54 RP <- <(_ ')' _)> */
  func() bool {
   position504, tokenIndex504 := position, tokenIndex
   {
position505 := position
   if !_rules[rule_]() {
   goto l504}
   if buffer[position] != rune(')') {
   goto l504}
position++
   if !_rules[rule_]() {
   goto l504}
add(ruleRP, position505)
   }
   return true
   l504:	
   position, tokenIndex = position504, tokenIndex504
   return false
  },
  /* 55 _ <- <(' ' / '\t' / '\n' / '\r')*> */
  func() bool {
   {
position507 := position
   l508:	
   {
   position509, tokenIndex509 := position, tokenIndex
   {
   position510, tokenIndex510 := position, tokenIndex
   if buffer[position] != rune(' ') {
   goto l511}
position++
   goto l510
   l511:	
   position, tokenIndex = position510, tokenIndex510
   if buffer[position] != rune('\t') {
   goto l512}
position++
   goto l510
   l512:	
   position, tokenIndex = position510, tokenIndex510
   if buffer[position] != rune('\n') {
   goto l513}
position++
   goto l510
   l513:	
   position, tokenIndex = position510, tokenIndex510
   if buffer[position] != rune('\r') {
   goto l509}
position++
   }
   l510:	
   goto l508
   l509:	
   position, tokenIndex = position509, tokenIndex509
   }
add(rule_, position507)
   }
   return true
  },
  /* 56 LiteralChar <- <(!('"' / '^' / '\n') .)> */
  func() bool {
   position514, tokenIndex514 := position, tokenIndex
   {
position515 := position
   {
   position516, tokenIndex516 := position, tokenIndex
   {
   position517, tokenIndex517 := position, tokenIndex
   if buffer[position] != rune('"') {
   goto l518}
position++
   goto l517
   l518:	
   position, tokenIndex = position517, tokenIndex517
   if buffer[position] != rune('^') {
   goto l519}
position++
   goto l517
   l519:	
   position, tokenIndex = position517, tokenIndex517
   if buffer[position] != rune('\n') {
   goto l516}
position++
   }
   l517:	
   goto l514
   l516:	
   position, tokenIndex = position516, tokenIndex516
   }
   if !matchDot() {
   goto l514}
add(ruleLiteralChar, position515)
   }
   return true
   l514:	
   position, tokenIndex = position514, tokenIndex514
   return false
  },
  /* 57 Float <- <('-'? Digit+ ('.' Digit+)? (('E' / 'e') ('+' / '-')? Digit+)?)> */
  func() bool {
   position520, tokenIndex520 := position, tokenIndex
   {
position521 := position
   {
   position522, tokenIndex522 := position, tokenIndex
   if buffer[position] != rune('-') {
   goto l522}
position++
   goto l523
   l522:	
   position, tokenIndex = position522, tokenIndex522
   }
   l523:	
   if !_rules[ruleDigit]() {
   goto l520}
   l524:	
   {
   position525, tokenIndex525 := position, tokenIndex
   if !_rules[ruleDigit]() {
   goto l525}
   goto l524
   l525:	
   position, tokenIndex = position525, tokenIndex525
   }
   {
   position526, tokenIndex526 := position, tokenIndex
   if buffer[position] != rune('.') {
   goto l526}
position++
   if !_rules[ruleDigit]() {
   goto l526}
   l528:	
   {
   position529, tokenIndex529 := position, tokenIndex
   if !_rules[ruleDigit]() {
   goto l529}
   goto l528
   l529:	
   position, tokenIndex = position529, tokenIndex529
   }
   goto l527
   l526:	
   position, tokenIndex = position526, tokenIndex526
   }
   l527:	
   {
   position530, tokenIndex530 := position, tokenIndex
   {
   position532, tokenIndex532 := position, tokenIndex
   if buffer[position] != rune('E') {
   goto l533}
position++
   goto l532
   l533:	
   position, tokenIndex = position532, tokenIndex532
   if buffer[position] != rune('e') {
   goto l530}
position++
   }
   l532:	
   {
   position534, tokenIndex534 := position, tokenIndex
   {
   position536, tokenIndex536 := position, tokenIndex
   if buffer[position] != rune('+') {
   goto l537}
position++
   goto l536
   l537:	
   position, tokenIndex = position536, tokenIndex536
   if buffer[position] != rune('-') {
   goto l534}
position++
   }
   l536:	
   goto l535
   l534:	
   position, tokenIndex = position534, tokenIndex534
   }
   l535:	
   if !_rules[ruleDigit]() {
   goto l530}
   l538:	
   {
   position539, tokenIndex539 := position, tokenIndex
   if !_rules[ruleDigit]() {
   goto l539}
   goto l538
   l539:	
   position, tokenIndex = position539, tokenIndex539
   }
   goto l531
   l530:	
   position, tokenIndex = position530, tokenIndex530
   }
   l531:	
add(ruleFloat, position521)
   }
   return true
   l520:	
   position, tokenIndex = position520, tokenIndex520
   return false
  },
  /* 58 Digit <- <[0-9]> */
  func() bool {
   position540, tokenIndex540 := position, tokenIndex
   {
position541 := position
   if c := buffer[position]; c < rune('0') || c > rune('9') {
   goto l540}
position++
add(ruleDigit, position541)
   }
   return true
   l540:	
   position, tokenIndex = position540, tokenIndex540
   return false
  },
  /* 60 Action0 <- <{ p.currentList = make([]string, 0) }> */
  func() bool {
   {
add(ruleAction0, position)
   }
   return true
  },
  /* 61 Action1 <- <{ p.Query.ResourceKinds = p.currentList }> */
  func() bool {
   {
add(ruleAction1, position)
   }
   return true
  },
  /* 62 Action2 <- <{ p.currentList = make([]string, 0) }> */
  func() bool {
   {
add(ruleAction2, position)
   }
   return true
  },
  /* 63 Action3 <- <{ p.Query.Name = p.currentList }> */
  func() bool {
   {
add(ruleAction3, position)
   }
   return true
  },
  /* 64 Action4 <- <{ p.currentList = make([]string, 0) }> */
  func() bool {
   {
add(ruleAction4, position)
   }
   return true
  },
  /* 65 Action5 <- <{ p.Query.Regex = p.currentList }> */
  func() bool {
   {
add(ruleAction5, position)
   }
   return true
  },
  /* 66 Action6 <- <{ p.currentList = make([]string, 0) }> */
  func() bool {
   {
add(ruleAction6, position)
   }
   return true
  },
  /* 67 Action7 <- <{ p.Query.Health = p.currentList }> */
  func() bool {
   {
add(ruleAction7, position)
   }
   return true
  },
  /* 68 Action8 <- <{ p.currentList = make([]string, 0) }> */
  func() bool {
   {
add(ruleAction8, position)
   }
   return true
  },
  /* 69 Action9 <- <{ p.Query.Status = p.currentList }> */
  func() bool {
   {
add(ruleAction9, position)
   }
   return true
  },
  /* 70 Action10 <- <{ p.currentList = make([]string, 0) }> */
  func() bool {
   {
add(ruleAction10, position)
   }
   return true
  },
  /* 71 Action11 <- <{ p.Query.State = p.currentList }> */
  func() bool {
   {
add(ruleAction11, position)
   }
   return true
  },
  nil,
  /* 73 Action12 <- <{ p.currentConditions = make([]Condition, 0) }> */
  func() bool {
   {
add(ruleAction12, position)
   }
   return true
  },
  /* 74 Action13 <- <{ p.Query.MetricsConditions = p.currentConditions }> */
  func() bool {
   {
add(ruleAction13, position)
   }
   return true
  },
  /* 75 Action14 <- <{ p.currentConditions = append(p.currentConditions, p.currentCondition.withConjunction(AndConjuction)) }> */
  func() bool {
   {
add(ruleAction14, position)
   }
   return true
  },
  nil,
  /* 77 Action15 <- <{ p.currentConjunction = text == "OR" ? OrConjuctive : AndConjuctive }> */
  func() bool {
   {
add(ruleAction15, position)
   }
   return true
  },
  /* 78 Action16 <- <{ p.currentConditions = append(p.currentConditions, p.currentCondition) }> */
  func() bool {
   {
add(ruleAction16, position)
   }
   return true
  },
  /* 79 Action17 <- <{ p.currentCondition.Operator = text}> */
  func() bool {
   {
add(ruleAction17, position)
   }
   return true
  },
  /* 80 Action18 <- <{ p.currentCondition.Identifier = text }> */
  func() bool {
   {
add(ruleAction18, position)
   }
   return true
  },
  /* 81 Action19 <- <{ p.currentCondition.Operator = text}> */
  func() bool {
   {
add(ruleAction19, position)
   }
   return true
  },
  /* 82 Action20 <- <{ p.currentCondition.Identifier = text}> */
  func() bool {
   {
add(ruleAction20, position)
   }
   return true
  },
  /* 83 Action21 <- <{ p.currentCondition.Operator = text }> */
  func() bool {
   {
add(ruleAction21, position)
   }
   return true
  },
  /* 84 Action22 <- <{ p.currentCondition.StringValue = text }> */
  func() bool {
   {
add(ruleAction22, position)
   }
   return true
  },
  /* 85 Action23 <- <{ p.currentCondition.DoubleValue = strconv.ParseFloat(text, 64) }> */
  func() bool {
   {
add(ruleAction23, position)
   }
   return true
  },
  /* 86 Action24 <- <{ p.currentList = make([]string, 0) }> */
  func() bool {
   {
add(ruleAction24, position)
   }
   return true
  },
  /* 87 Action25 <- <{ p.Query.Metrics = p.currentList}> */
  func() bool {
   {
add(ruleAction25, position)
   }
   return true
  },
  /* 88 Action26 <- <{ p.currentList = append(p.currentList, text)}> */
  func() bool {
   {
add(ruleAction26, position)
   }
   return true
  },
  /* 89 Action27 <- <{ p.currentList = append(p.currentList, text)}> */
  func() bool {
   {
add(ruleAction27, position)
   }
   return true
  },
  /* 90 Action28 <- <{ p.currentList = append(p.currentList, p.currentText )}> */
  func() bool {
   {
add(ruleAction28, position)
   }
   return true
  },
  /* 91 Action29 <- <{ p.currentList = append(p.currentList, p.currentText) }> */
  func() bool {
   {
add(ruleAction29, position)
   }
   return true
  },
  /* 92 Action30 <- <{ p.currentText = text }> */
  func() bool {
   {
add(ruleAction30, position)
   }
   return true
  },
 }
 p.rules = _rules
 return nil
}
