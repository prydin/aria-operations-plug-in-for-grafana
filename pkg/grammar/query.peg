#go:build grammars
# +build grammars

package grammar

type QueryParser Peg {
    Query               RawQuery

    currentText         string
    currentList         []string
    currentCondition    Condition
    currentConditions   []Condition
    currentConjunctive  string    
}

Query <- 
    TypeSpec 
    ( Dot Filter )+ 
    Dot Metrics !.

TypeSpec <- 
    <RESOURCE> { p.currentList = make([]string, 0) } 
    LP IdentifierList RP { p.Query.ResourceKinds = p.currentList }

Filter <-
    NAME { p.currentList = make([]string, 0) }
    LP LiteralStringList RP { p.Query.Name = p.currentList } 
  / REGEX { p.currentList = make([]string, 0) }
    LP LiteralStringList RP { p.Query.Regex = p.currentList } 
  / WHERE_HEALTH { p.currentList = make([]string, 0) }
    LP IdentifierList RP { p.Query.Health = p.currentList }
  / WHERE_STATUS { p.currentList = make([]string, 0) }
    LP IdentifierList RP { p.Query.Status = p.currentList }
  / WHERE_STATE { p.currentList = make([]string, 0) }
    LP IdentifierList RP { p.Query.State = p.currentList }
  / WHERE_METRICS { p.currentConditions = make([]Condition, 0) }
    LP Conditions RP { p.Query.MetricConditions = p.currentConditions }
  / WHERE_PROPERTIES { p.currentConditions = make([]Condition, 0) }
    LP Conditions RP { p.Query.PropertyConditions = p.currentConditions } 

Conditions <- 
    Term { p.currentConditions = append(p.currentConditions, *p.currentCondition.WithConjunctive("")) }
        ( _ <Conjunctive> _ { p.currentConjunctive = strings.ToUpper(text) } 
        Term { p.currentConditions = append(p.currentConditions, *p.currentCondition.WithConjunctive(p.currentConjunctive)) })*
Term <- 
    Function 
  / InfixExpression

Conjunctive <- 
    AND
  / OR

Function <-
    UnaryFunction
  / BinaryFunction

UnaryFunction <-
    <UnaryFunctionName> { p.currentCondition.Operator = text} 
    LP <Identifier> { p.currentCondition.Key = text } RP

UnaryFunctionName <-
    EXISTS
  / NOT_EXISTS

BinaryFunctionName <- 
    CONTAINS
  / STARTS_WITH
  / ENDS_WITH
  / REGEX
  / NOT_CONTAINS
  / NOT_STARTS_WITH
  / NOT_ENDS_WITH
  / NOT_REGEX
  / IN
  / NOT_IN

Operator <-
    EQ
  / NE
  / LTE
  / LT
  / GTE
  / GT

BinaryFunction <- 
    <BinaryFunctionName> { p.currentCondition.Operator = text}  
    LP <Identifier> { p.currentCondition.Key = text} Comma LiteralConditionValue RP

InfixExpression <-
    <Identifier> { p.currentCondition.Key = text } _ <Operator> { p.currentCondition.Operator = text } _ LiteralConditionValue

LiteralConditionValue <-
    <LiteralString> { p.currentCondition.StringValue = text }
  / <Float> { p.currentCondition.DoubleValue, _ = strconv.ParseFloat(text, 64) }


Metrics <- 
    METRICS { p.currentList = make([]string, 0) } LP IdentifierList RP { p.Query.Metrics = p.currentList}

# Identifiers    
Identifier <-
    IDStartCharacter IDCharacter* /
    BackTick <IDQuotedCharacter+> BackTick

IdentifierList <- 
    <Identifier> { p.currentList = append(p.currentList, text)} 
    (Comma <Identifier> { p.currentList = append(p.currentList, text)} )*

LiteralStringList <- 
    <LiteralString> { p.currentList = append(p.currentList, p.currentText )}
    (Comma <LiteralString> { p.currentList = append(p.currentList, p.currentText) })*

IDStartCharacter        <- [A-Za-z_]
IDCharacter             <- [A-Za-z0-9_:|.\-]
IDQuotedCharacter       <- [A-Za-z0-9_:|.\- ,$]
LiteralString           <- Quote <LiteralChar*> { p.currentText = text } Quote 

# Reserved words
METRICS                 <- 'metrics'
NAME                    <- 'name'
REGEX                   <- 'regex'
RESOURCE                <- 'resource'
WHERE_HEALTH            <- 'whereHealth'
WHERE_STATE             <- 'whereState'
WHERE_STATUS            <- 'whereStatus'
WHERE_METRICS           <- 'whereMetrics'
WHERE_PROPERTIES        <- 'whereProperties'

AND                     <- 'and'
OR                      <- 'or'
IN                      <- 'in'
NOT_IN                  <- 'not in'
CONTAINS                <- 'contains'
STARTS_WITH             <- 'starts_with'
ENDS_WITH               <- 'ends_with'
NOT_STARTS_WITH         <- 'not starts_with'
NOT_ENDS_WITH           <- 'not ends_with'
NOT_CONTAINS            <- 'not contains'
NOT_REGEX               <- 'not regex'
EXISTS                  <- 'exists'
NOT_EXISTS              <- 'not exists'
GT                      <- '>'
LT                      <- '<'
GTE                     <- '>='
LTE                     <- '<='
EQ                      <- '='
NE                      <- '!='

# Lexical tokens
Quote                   <- '"'
Comma                   <- _ ',' _
BackTick                <- '`'
Dot                     <- _ '.' _
LP                      <- _ '(' _
RP                      <- _ ')' _
_                       <- [ \t\n\r]*
LiteralChar             <- [^"^\n]
Float                   <- '-'? [0-9]+ ('.' [0-9]+)? ([Ee] [+\-]? [0-9]+)?
