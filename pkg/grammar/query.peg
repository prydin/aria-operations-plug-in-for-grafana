# Aria Operations plug-in for Grafana
# Copyright 2023 VMware, Inc.
#
# The BSD-2 license (the "License") set forth below applies to all parts of the 
# Aria Operations plug-in for Grafana project. You may not use this file except 
# in compliance with the License.
#
# # BSD-2 License
# Redistribution and use in source and binary forms, with or without 
# modification, are permitted provided that the following conditions are met:
#
# Redistributions of source code must retain the above copyright notice, 
# this list of conditions and the following disclaimer.
#
# Redistributions in binary form must reproduce the above copyright notice, this
# list of conditions and the following disclaimer in the documentation and/or 
# other materials provided with the distribution.
#
# THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND
# ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED 
# WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE 
# DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE 
# FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL 
# DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR 
# SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER 
# CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, 
# OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
# OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.

#go:build grammars
# +build grammars

package grammar

type QueryParser Peg {
    Query               RawQuery

    currentText         string
    currentList         []string
    currentCondition    Condition
    currentConditions   []Condition
    currentConjunctive  string    
    currentFloat        float64
}

Query <- 
    TypeSpec 
    ( Dot Filter )+ 
    Dot Metrics 
    ( Dot Aggregation )? !.

TypeSpec <- 
    <RESOURCE> { p.currentList = make([]string, 0) } 
    LP IdentifierList RP { p.Query.ResourceKinds = p.currentList }

Filter <-
    NAME { p.currentList = make([]string, 0) }
    LP LiteralStringList RP { p.Query.Name = p.currentList } 
  / REGEX { p.currentList = make([]string, 0) }
    LP LiteralStringList RP { p.Query.Regex = p.currentList } 
  / WHERE_HEALTH { p.currentList = make([]string, 0) }
    LP IdentifierList RP { p.Query.Health = p.currentList }
  / WHERE_STATUS { p.currentList = make([]string, 0) }
    LP IdentifierList RP { p.Query.Status = p.currentList }
  / WHERE_STATE { p.currentList = make([]string, 0) }
    LP IdentifierList RP { p.Query.State = p.currentList }
  / WHERE_METRICS { p.currentConditions = make([]Condition, 0) }
    LP Conditions RP { p.Query.MetricConditions = p.currentConditions }
  / WHERE_PROPERTIES { p.currentConditions = make([]Condition, 0) }
    LP Conditions RP { p.Query.PropertyConditions = p.currentConditions } 

Conditions <- 
    Term { p.currentConditions = append(p.currentConditions, *p.currentCondition.WithConjunctive("")) }
        ( _ <Conjunctive> _ { p.currentConjunctive = strings.ToUpper(text) } 
        Term { p.currentConditions = append(p.currentConditions, *p.currentCondition.WithConjunctive(p.currentConjunctive)) })*
Term <- 
    Function 
  / InfixExpression

Conjunctive <- 
    AND
  / OR

Function <-
    UnaryFunction
  / BinaryFunction

UnaryFunction <-
    <UnaryFunctionName> { p.currentCondition.Operator = text} 
    LP <Identifier> { p.currentCondition.Key = text } RP

UnaryFunctionName <-
    EXISTS
  / NOT_EXISTS

BinaryFunctionName <- 
    CONTAINS
  / STARTS_WITH
  / ENDS_WITH
  / REGEX
  / NOT_CONTAINS
  / NOT_STARTS_WITH
  / NOT_ENDS_WITH
  / NOT_REGEX
  / IN
  / NOT_IN

Operator <-
    EQ
  / NE
  / LTE
  / LT
  / GTE
  / GT

BinaryFunction <- 
    <BinaryFunctionName> { p.currentCondition.Operator = text}  
    LP <Identifier> { p.currentCondition.Key = text} Comma LiteralConditionValue RP

InfixExpression <-
    <Identifier> { p.currentCondition.Key = text } _ <Operator> { p.currentCondition.Operator = text } _ LiteralConditionValue

LiteralConditionValue <-
    <LiteralString> { p.currentCondition.StringValue = &text }
  / Float { 
      tmp := p.currentFloat
      p.currentCondition.DoubleValue = &tmp
    }

Metrics <- 
    METRICS { p.currentList = make([]string, 0) } LP IdentifierList RP { p.Query.Metrics = p.currentList }

Aggregation <- 
  < AVG / MIN / MAX / STDDEV / VARIANCE / MEDIAN / COUNT / SUM > { p.Query.Aggregation.Type = text } 
    LP { p.currentList = make([]string, 0) } IdentifierList? { p.Query.Aggregation.Properties = p.currentList } RP 
  / PERCENTILE { p.Query.Aggregation.Type = text } 
    LP { p.currentList = make([]string, 0) } Float { p.Query.Aggregation.Parameter = p.currentFloat } 
      Comma IdentifierList? { p.Query.Aggregation.Properties = p.currentList } RP

# Identifiers    
Identifier <-
    IDStartCharacter IDCharacter* /
    BackTick <IDQuotedCharacter+> BackTick

IdentifierList <- 
    <Identifier> { p.currentList = append(p.currentList, text)} 
    (Comma <Identifier> { p.currentList = append(p.currentList, text)} )*

LiteralStringList <- 
    <LiteralString> { p.currentList = append(p.currentList, p.currentText )}
    (Comma <LiteralString> { p.currentList = append(p.currentList, p.currentText) })*

IDStartCharacter        <- [A-Za-z_]
IDCharacter             <- [A-Za-z0-9_:|.\-]
IDQuotedCharacter       <- [A-Za-z0-9_:|.\- ,$]
LiteralString           <- Quote <LiteralChar*> { p.currentText = text } Quote 

# Reserved words
METRICS                 <- 'metrics'
NAME                    <- 'name'
REGEX                   <- 'regex'
RESOURCE                <- 'resource'
WHERE_HEALTH            <- 'whereHealth'
WHERE_STATE             <- 'whereState'
WHERE_STATUS            <- 'whereStatus'
WHERE_METRICS           <- 'whereMetrics'
WHERE_PROPERTIES        <- 'whereProperties'

AND                     <- 'and'
OR                      <- 'or'
IN                      <- 'in'
NOT_IN                  <- 'not in'
CONTAINS                <- 'contains'
STARTS_WITH             <- 'starts_with'
ENDS_WITH               <- 'ends_with'
NOT_STARTS_WITH         <- 'not starts_with'
NOT_ENDS_WITH           <- 'not ends_with'
NOT_CONTAINS            <- 'not contains'
NOT_REGEX               <- 'not regex'
EXISTS                  <- 'exists'
NOT_EXISTS              <- 'not exists'
GT                      <- '>'
LT                      <- '<'
GTE                     <- '>='
LTE                     <- '<='
EQ                      <- '='
NE                      <- '!='

AVG                     <- 'avg'
MIN                     <- 'min'
MAX                     <- 'max'
COUNT                   <- 'count'
SUM                     <- 'sum'
STDDEV                  <- 'stddev'
VARIANCE                <- 'variance'
MEDIAN                  <- 'median'
PERCENTILE              <- 'percentile'

# Lexical tokens
Quote                   <- '"'
Comma                   <- _ ',' _
BackTick                <- '`'
Dot                     <- _ '.' _
LP                      <- _ '(' _
RP                      <- _ ')' _
_                       <- [ \t\n\r]*
LiteralChar             <- [^"^\n]
Float                   <- <'-'? [0-9]+ ('.' [0-9]+)? ([Ee] [+\-]? [0-9]+)?> { p.currentFloat, _ = strconv.ParseFloat(text, 64) }
