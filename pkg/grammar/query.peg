# Aria Operations plug-in for Grafana
# Copyright 2023 VMware, Inc.
#
# The BSD-2 license (the "License") set forth below applies to all parts of the 
# Aria Operations plug-in for Grafana project. You may not use this file except 
# in compliance with the License.
#
# # BSD-2 License
# Redistribution and use in source and binary forms, with or without 
# modification, are permitted provided that the following conditions are met:
#
# Redistributions of source code must retain the above copyright notice, 
# this list of conditions and the following disclaimer.
#
# Redistributions in binary form must reproduce the above copyright notice, this
# list of conditions and the following disclaimer in the documentation and/or 
# other materials provided with the distribution.
#
# THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND
# ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED 
# WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE 
# DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE 
# FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL 
# DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR 
# SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER 
# CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, 
# OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
# OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.

#go:build grammars
# +build grammars

package grammar

type QueryParser Peg {
    Query               RawQuery
    stack               []any
}

Query <-
    TypeSpec 
    ( Dot Filter )* 
    Dot Metrics 
    ( Dot Aggregation )? 
    ( Dot Smoother )? !.

TypeSpec <- 
    <RESOURCE> LP IdentifierList RP { p.Query.ResourceKinds = p.PopList() }

Filter <-
    NAME LP LiteralStringList RP { p.Query.Name = p.PopList() } 
  / REGEX LP LiteralStringList RP { p.Query.Regex = p.PopList() } 
  / WHERE_HEALTH LP IdentifierList RP { p.Query.Health = p.PopList() }
  / WHERE_STATUS LP IdentifierList RP { p.Query.Status = p.PopList() }
  / WHERE_STATE LP IdentifierList RP { p.Query.State = p.PopList() }
  / WHERE_METRICS LP Conditions RP { p.Query.MetricConditions = p.PopConditions() }
  / WHERE_PROPERTIES LP Conditions RP { p.Query.PropertyConditions = p.PopConditions() } 

Conditions <- 
    Term { p.Push([]*Condition { p.PopCondition() })  }
        ( _ Conjunctive _ 
        Term { 
          cond := p.PopCondition()
          conj := p.PopString()
          p.PushConditionIntoList(cond.WithConjunctive(conj))} )*
Term <- 
    Function 
  / InfixExpression

Conjunctive <- 
    <AND / OR> { p.Push(strings.ToUpper(text)) }

Function <-
    UnaryFunction 
  / BinaryFunction 

UnaryFunction <-
    UnaryFunctionName 
    LP Identifier RP { 
      id := p.PopString()
      op := p.PopString()
      p.Push(&Condition { Key: id, Operator: op })
    }

UnaryFunctionName <-
  ( EXISTS
  / NOT_EXISTS ) { p.Push(text) }

BinaryFunctionName <- 
    ( CONTAINS        { p.Push("CONTAINS") }
    / STARTS_WITH     { p.Push("STARTS_WITH") }
    / ENDS_WITH       { p.Push("ENDS_WITH") }
    / REGEX           { p.Push("REGEX") }
    / NOT_CONTAINS    { p.Push("NOT_CONTAINS") }
    / NOT_STARTS_WITH { p.Push("NOT_STARTS_WITH") }
    / NOT_ENDS_WITH   { p.Push("NOT_ENDS_WITH") }
    / NOT_REGEX       { p.Push("NOT_REGEX") }
    / IN              { p.Push("IN") }
    / NOT_IN          { p.Push("NOT_IN") } ) { p.Push(text) }

Operator <-
    EQ                { p.Push("EQ") }
  / NE                { p.Push("NE") }
  / LTE               { p.Push("LTE") }
  / LT                { p.Push("LT") }
  / GTE               { p.Push("GTE") }
  / GT                { p.Push("GT") }

BinaryFunction <- 
    BinaryFunctionName
    LP Identifier Comma LiteralConditionValue RP { 
      val := p.Pop()
      id := p.PopString()
      op := p.PopString()
      p.Push(&Condition { Key: id, Operator: op, Value: val })
    }

InfixExpression <-
    Identifier _ Operator _ LiteralConditionValue { 
      val := p.Pop()
      op := p.PopString()
      id := p.PopString()
      p.Push(&Condition { Key: id, Operator: op, Value: val })
    }

LiteralConditionValue <-
    LiteralString / Float 

Metrics <- 
    METRICS LP IdentifierList RP { p.Query.Metrics = p.PopList() }

Aggregation <- 
  < AVG / MIN / MAX / STDDEV / VARIANCE / MEDIAN / COUNT / SUM > { p.Query.Aggregation.Type = text } 
    LP (IdentifierList { p.Query.Aggregation.Properties = p.PopList() })? RP 
  / <PERCENTILE> { p.Query.Aggregation.Type = text } 
    LP Float { p.Query.Aggregation.Parameter = p.PopFloat() } 
      ((Comma IdentifierList) { p.Query.Aggregation.Properties = p.PopList() } )? RP

Smoother <- 
  < MAVG / MSUM / MSTDDEV / MVARIANCE / MMEDIAN / MMAX / MMIN / MEXPAVG / MGAUSSIAN > { p.Query.Smoother.Type = text }
    LP TimeSpecifier { p.Query.Smoother.WindowSize = int64(p.PopFloat())} (Comma <Boolean> { p.Query.Smoother.Shift = p.Pop().(bool) })? RP 

# Identifiers    
Identifier <-
    <IDStartCharacter IDCharacter*> { p.Push(text) }/
    BackTick <IDQuotedCharacter+> { p.Push(text) } BackTick

IdentifierList <- 
    Identifier { p.Push([]string { p.PopString() }) }
    (Comma Identifier { p.PushStringIntoList(p.PopString()) } )*

# Literals
LiteralStringList <- 
    LiteralString { p.Push([]string { p.PopString() }) }
    (Comma LiteralString { p.PushStringIntoList(p.PopString()) })*

IDStartCharacter        <- [A-Za-z_]
IDCharacter             <- [A-Za-z0-9_:|.\-]
IDQuotedCharacter       <- [A-Za-z0-9_:|.\- ,$]
LiteralString           <- Quote <LiteralChar*> { p.Push(text) } Quote 
Boolean                 <- <'true' / 'false'> { p.Push(text == "true") }
TimeSpecifier           <- Float TimeUnit { p.Push(p.PopFloat() * p.PopFloat())}
TimeUnit                <-  's' { p.Push(float64(1000)) }
                          / 'm' { p.Push(float64(1000*60)) }
                          / 'h' { p.Push(float64(1000*60*60)) }
                          / 'd' { p.Push(float64(1000*60*60*24)) }
                          / 'w' { p.Push(float64(1000*60*60*24*7)) }
                          / 'y' { p.Push(float64(1000*60*60*24*365)) }

# Reserved words
METRICS                 <- 'metrics'
NAME                    <- 'name'
REGEX                   <- 'regex'
RESOURCE                <- 'resource'
WHERE_HEALTH            <- 'whereHealth'
WHERE_STATE             <- 'whereState'
WHERE_STATUS            <- 'whereStatus'
WHERE_METRICS           <- 'whereMetrics'
WHERE_PROPERTIES        <- 'whereProperties'

# Expression language
AND                     <- 'and'
OR                      <- 'or'
IN                      <- 'in'
NOT_IN                  <- 'not in'
CONTAINS                <- 'contains'
STARTS_WITH             <- 'starts_with'
ENDS_WITH               <- 'ends_with'
NOT_STARTS_WITH         <- 'not starts_with'
NOT_ENDS_WITH           <- 'not ends_with'
NOT_CONTAINS            <- 'not contains'
NOT_REGEX               <- 'not regex'
EXISTS                  <- 'exists'
NOT_EXISTS              <- 'not exists'
GT                      <- '>'
LT                      <- '<'
GTE                     <- '>='
LTE                     <- '<='
EQ                      <- '='
NE                      <- '!='

# Aggregations
AVG                     <- 'avg'
MIN                     <- 'min'
MAX                     <- 'max'
COUNT                   <- 'count'
SUM                     <- 'sum'
STDDEV                  <- 'stddev'
VARIANCE                <- 'variance'
MEDIAN                  <- 'median'
PERCENTILE              <- 'percentile'

# Smoothers
MAVG                    <- "mavg" 
MSTDDEV                 <- "mstddev"
MVARIANCE               <- "mvariance"
MMEDIAN                 <- "mmedian"
MMAX                    <- "mmax"
MMIN                    <- "mmin"
MSUM                    <- "msum"
MEXPAVG                 <- "mexpavg"
MGAUSSIAN               <- "mgaussian"


# Lexical tokens
Quote                   <- '"'
Comma                   <- _ ',' _
BackTick                <- '`'
Dot                     <- _ '.' _
LP                      <- _ '(' _
RP                      <- _ ')' _
_                       <- [ \t\n\r]*
LiteralChar             <- [^"^\n]
Float                   <- <'-'? [0-9]+ ('.' [0-9]+)? ([Ee] [+\-]? [0-9]+)?> { tmp, _ := strconv.ParseFloat(text, 64); p.Push(tmp) }
